"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./hooks/trading/useChartInteractions.ts":
/*!***********************************************!*\
  !*** ./hooks/trading/useChartInteractions.ts ***!
  \***********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useChartInteractions: () => (/* binding */ useChartInteractions)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.2.4_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils_trading_calculations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/trading/calculations */ \"(app-pages-browser)/./utils/trading/calculations.ts\");\n/**\n * Chart Interactions Hook\n * Manages mouse events, drawing tools, and chart interactions with ultra-fast axis-specific zoom\n */ \n\nconst useChartInteractions = (param)=>{\n    let { canvasRef, candleData, drawingMode, drawingTools, selectedDrawingIndex, viewportState, dragState, setHoveredCandle, setMousePosition, setDrawingTools, setSelectedDrawingIndex, setDrawingMode, setSelectedDrawingTool, setDragState, setViewportState } = param;\n    /**\n   * Detect if mouse is over Y-axis (price axis) or X-axis (time axis)\n   */ const getAxisZone = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useChartInteractions.useCallback[getAxisZone]\": (x, y, canvas)=>{\n            const rect = canvas.getBoundingClientRect();\n            const priceAxisWidth = 80 // Right side price axis (w-20 = 80px)\n            ;\n            const timeAxisHeight = 32 // Bottom time axis (h-8 = 32px)\n            ;\n            const chartWidth = rect.width - priceAxisWidth;\n            const chartHeight = rect.height - timeAxisHeight;\n            // Check if in price axis zone (right edge)\n            if (x >= chartWidth && x <= rect.width) {\n                return 'price-axis';\n            }\n            // Check if in time axis zone (bottom edge)  \n            if (y >= chartHeight && y <= rect.height) {\n                return 'time-axis';\n            }\n            // Check if near price axis edge (for drag detection)\n            if (x >= chartWidth - 15 && x <= chartWidth + 15) {\n                return 'price-axis-edge';\n            }\n            // Check if near time axis edge (for drag detection)\n            if (y >= chartHeight - 15 && y <= chartHeight + 15) {\n                return 'time-axis-edge';\n            }\n            return 'chart';\n        }\n    }[\"useChartInteractions.useCallback[getAxisZone]\"], []);\n    /**\n   * Handle mouse movement for crosshair, candle hover, and axis detection\n   */ const handleMouseMove = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useChartInteractions.useCallback[handleMouseMove]\": (event)=>{\n            const canvas = canvasRef.current;\n            if (!canvas) return;\n            const rect = canvas.getBoundingClientRect();\n            const x = event.clientX - rect.left;\n            const y = event.clientY - rect.top;\n            // Handle active axis dragging only\n            if (dragState.isDraggingPrice) {\n                const deltaY = y - dragState.dragStart.y;\n                const sensitivity = 0.002 // Ultra-sensitive for professional trading\n                ;\n                const zoomFactor = 1 + deltaY * sensitivity;\n                setViewportState({\n                    \"useChartInteractions.useCallback[handleMouseMove]\": (prev)=>({\n                            ...prev,\n                            priceZoom: Math.max(0.05, Math.min(50, prev.priceZoom * zoomFactor))\n                        })\n                }[\"useChartInteractions.useCallback[handleMouseMove]\"]);\n                // Update drag start for continuous movement\n                setDragState({\n                    \"useChartInteractions.useCallback[handleMouseMove]\": (prev)=>({\n                            ...prev,\n                            dragStart: {\n                                x,\n                                y\n                            }\n                        })\n                }[\"useChartInteractions.useCallback[handleMouseMove]\"]);\n                return;\n            }\n            if (dragState.isDraggingTime) {\n                const deltaX = x - dragState.dragStart.x;\n                const sensitivity = 0.002 // Ultra-sensitive for professional trading\n                ;\n                const zoomFactor = 1 + deltaX * sensitivity;\n                setViewportState({\n                    \"useChartInteractions.useCallback[handleMouseMove]\": (prev)=>({\n                            ...prev,\n                            timeZoom: Math.max(0.05, Math.min(50, prev.timeZoom * zoomFactor))\n                        })\n                }[\"useChartInteractions.useCallback[handleMouseMove]\"]);\n                // Update drag start for continuous movement\n                setDragState({\n                    \"useChartInteractions.useCallback[handleMouseMove]\": (prev)=>({\n                            ...prev,\n                            dragStart: {\n                                x,\n                                y\n                            }\n                        })\n                }[\"useChartInteractions.useCallback[handleMouseMove]\"]);\n                return;\n            }\n            // Don't interfere with existing chart dragging - let trading terminal handle it\n            if (dragState.isDraggingChart) {\n                return;\n            }\n            // Detect axis zones and update cursor\n            const axisZone = getAxisZone(x, y, canvas);\n            if (axisZone === 'price-axis' || axisZone === 'price-axis-edge') {\n                canvas.style.cursor = 'ns-resize';\n            } else if (axisZone === 'time-axis' || axisZone === 'time-axis-edge') {\n                canvas.style.cursor = 'ew-resize';\n            } else {\n                canvas.style.cursor = 'move';\n            }\n            // Calculate which candle is being hovered\n            const candleWidth = 8 * viewportState.timeZoom;\n            const spacing = 12 * viewportState.timeZoom;\n            const startX = 50;\n            const candleIndex = Math.floor((x - startX + viewportState.timeOffset) / spacing);\n            if (candleIndex >= 0 && candleIndex < candleData.length) {\n                setHoveredCandle(candleData[candleIndex]);\n            }\n            // Calculate price at mouse position\n            const chartHeight = canvas.offsetHeight - 100;\n            const priceRange = (113000 - 107000) / viewportState.priceZoom;\n            const price = 113000 - (y - 50 + viewportState.priceOffset) / chartHeight * priceRange;\n            setMousePosition({\n                x,\n                y,\n                price\n            });\n        }\n    }[\"useChartInteractions.useCallback[handleMouseMove]\"], [\n        viewportState,\n        candleData,\n        dragState,\n        setHoveredCandle,\n        setMousePosition,\n        setViewportState,\n        setDragState,\n        getAxisZone\n    ]);\n    /**\n   * Handle mouse down events for axis dragging only\n   */ const handleCanvasMouseDown = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useChartInteractions.useCallback[handleCanvasMouseDown]\": (e)=>{\n            const canvas = canvasRef.current;\n            if (!canvas) return;\n            const rect = canvas.getBoundingClientRect();\n            const x = e.clientX - rect.left;\n            const y = e.clientY - rect.top;\n            // Check for axis dragging first - this takes priority\n            const axisZone = getAxisZone(x, y, canvas);\n            if (axisZone === 'price-axis' || axisZone === 'price-axis-edge') {\n                setDragState({\n                    \"useChartInteractions.useCallback[handleCanvasMouseDown]\": (prev)=>({\n                            ...prev,\n                            isDraggingPrice: true,\n                            dragStart: {\n                                x,\n                                y\n                            }\n                        })\n                }[\"useChartInteractions.useCallback[handleCanvasMouseDown]\"]);\n                e.preventDefault();\n                e.stopPropagation();\n                return;\n            }\n            if (axisZone === 'time-axis' || axisZone === 'time-axis-edge') {\n                setDragState({\n                    \"useChartInteractions.useCallback[handleCanvasMouseDown]\": (prev)=>({\n                            ...prev,\n                            isDraggingTime: true,\n                            dragStart: {\n                                x,\n                                y\n                            }\n                        })\n                }[\"useChartInteractions.useCallback[handleCanvasMouseDown]\"]);\n                e.preventDefault();\n                e.stopPropagation();\n                return;\n            }\n            // For chart area, let the existing drawing and chart drag system handle it\n            const { timeIndex, price } = (0,_utils_trading_calculations__WEBPACK_IMPORTED_MODULE_1__.screenToChartCoordinates)(x, y, canvas, viewportState.timeZoom, viewportState.priceZoom, viewportState.timeOffset, viewportState.priceOffset);\n            // Find clicked drawing\n            let clickedDrawingIndex = -1;\n            let closestDistance = Infinity;\n            drawingTools.forEach({\n                \"useChartInteractions.useCallback[handleCanvasMouseDown]\": (tool, index)=>{\n                    if ((0,_utils_trading_calculations__WEBPACK_IMPORTED_MODULE_1__.isPointInDrawing)(timeIndex, price, tool)) {\n                        if (tool.type === \"Horizontal Ray\") {\n                            const distance = Math.abs(price - tool.price1);\n                            if (distance < closestDistance) {\n                                closestDistance = distance;\n                                clickedDrawingIndex = index;\n                            }\n                        } else {\n                            clickedDrawingIndex = index;\n                        }\n                    }\n                }\n            }[\"useChartInteractions.useCallback[handleCanvasMouseDown]\"]);\n            // Right-click to remove drawings\n            if (e.button === 2) {\n                e.preventDefault();\n                if (clickedDrawingIndex !== -1) {\n                    setDrawingTools({\n                        \"useChartInteractions.useCallback[handleCanvasMouseDown]\": (prev)=>{\n                            const updatedTools = [\n                                ...prev\n                            ];\n                            updatedTools.splice(clickedDrawingIndex, 1);\n                            return updatedTools;\n                        }\n                    }[\"useChartInteractions.useCallback[handleCanvasMouseDown]\"]);\n                    setSelectedDrawingIndex(null);\n                }\n                return;\n            }\n            // Left-click to select drawing or start new drawing\n            if (clickedDrawingIndex !== -1) {\n                setSelectedDrawingIndex(clickedDrawingIndex);\n                return;\n            } else {\n                setSelectedDrawingIndex(null);\n            }\n            // Handle drawing mode\n            if (drawingMode === \"Horizontal Ray\") {\n                setDrawingTools({\n                    \"useChartInteractions.useCallback[handleCanvasMouseDown]\": (prev)=>[\n                            ...prev,\n                            {\n                                type: \"Horizontal Ray\",\n                                price1: price,\n                                time1: 0,\n                                price2: price,\n                                time2: candleData.length,\n                                color: \"#ffff00\",\n                                lineWidth: 1\n                            }\n                        ]\n                }[\"useChartInteractions.useCallback[handleCanvasMouseDown]\"]);\n                setDrawingMode(null);\n                setSelectedDrawingTool(null);\n            } else if (drawingMode === \"Rectangle\") {\n                setDrawingTools({\n                    \"useChartInteractions.useCallback[handleCanvasMouseDown]\": (prev)=>[\n                            ...prev,\n                            {\n                                type: \"Rectangle\",\n                                price1: price,\n                                time1: timeIndex,\n                                price2: price,\n                                time2: timeIndex,\n                                color: \"#ffff00\",\n                                lineWidth: 1\n                            }\n                        ]\n                }[\"useChartInteractions.useCallback[handleCanvasMouseDown]\"]);\n            }\n        // Let the trading terminal handle chart panning - don't set isDraggingChart here\n        }\n    }[\"useChartInteractions.useCallback[handleCanvasMouseDown]\"], [\n        canvasRef,\n        viewportState,\n        drawingTools,\n        drawingMode,\n        candleData,\n        setDrawingTools,\n        setSelectedDrawingIndex,\n        setDrawingMode,\n        setSelectedDrawingTool,\n        setDragState,\n        getAxisZone\n    ]);\n    /**\n   * Handle mouse up events to stop axis dragging\n   */ const handleAxisDragEnd = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useChartInteractions.useCallback[handleAxisDragEnd]\": ()=>{\n            setDragState({\n                \"useChartInteractions.useCallback[handleAxisDragEnd]\": (prev)=>({\n                        ...prev,\n                        isDraggingPrice: false,\n                        isDraggingTime: false,\n                        isDraggingChart: false,\n                        isDraggingOrderbook: false,\n                        isDraggingCvd: false,\n                        isDraggingLiquidations: false\n                    })\n            }[\"useChartInteractions.useCallback[handleAxisDragEnd]\"]);\n        }\n    }[\"useChartInteractions.useCallback[handleAxisDragEnd]\"], [\n        setDragState\n    ]);\n    /**\n   * Handle keyboard shortcuts for drawing management\n   */ (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useChartInteractions.useEffect\": ()=>{\n            const handleKeyDown = {\n                \"useChartInteractions.useEffect.handleKeyDown\": (event)=>{\n                    if (event.key === 'Delete' || event.key === 'Backspace') {\n                        if (selectedDrawingIndex !== null) {\n                            setDrawingTools({\n                                \"useChartInteractions.useEffect.handleKeyDown\": (prev)=>{\n                                    const updatedTools = [\n                                        ...prev\n                                    ];\n                                    updatedTools.splice(selectedDrawingIndex, 1);\n                                    return updatedTools;\n                                }\n                            }[\"useChartInteractions.useEffect.handleKeyDown\"]);\n                            setSelectedDrawingIndex(null);\n                        }\n                    }\n                    if (event.key === 'Escape') {\n                        setSelectedDrawingIndex(null);\n                        setDrawingMode(null);\n                        setSelectedDrawingTool(null);\n                        // Stop any dragging\n                        setDragState({\n                            \"useChartInteractions.useEffect.handleKeyDown\": (prev)=>({\n                                    ...prev,\n                                    isDraggingPrice: false,\n                                    isDraggingTime: false,\n                                    isDraggingChart: false,\n                                    isDraggingOrderbook: false,\n                                    isDraggingCvd: false,\n                                    isDraggingLiquidations: false\n                                })\n                        }[\"useChartInteractions.useEffect.handleKeyDown\"]);\n                    }\n                }\n            }[\"useChartInteractions.useEffect.handleKeyDown\"];\n            document.addEventListener('keydown', handleKeyDown);\n            return ({\n                \"useChartInteractions.useEffect\": ()=>{\n                    document.removeEventListener('keydown', handleKeyDown);\n                }\n            })[\"useChartInteractions.useEffect\"];\n        }\n    }[\"useChartInteractions.useEffect\"], [\n        selectedDrawingIndex,\n        setDrawingTools,\n        setSelectedDrawingIndex,\n        setDrawingMode,\n        setSelectedDrawingTool,\n        setDragState\n    ]);\n    /**\n   * Handle wheel events for ultra-fast zooming with axis detection\n   */ const handleWheel = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useChartInteractions.useCallback[handleWheel]\": (e)=>{\n            e.preventDefault();\n            const canvas = canvasRef.current;\n            if (!canvas) return;\n            const rect = canvas.getBoundingClientRect();\n            const x = e.clientX - rect.left;\n            const y = e.clientY - rect.top;\n            // Detect which axis we're hovering over\n            const axisZone = getAxisZone(x, y, canvas);\n            // Ultra-aggressive zoom factors for lightning-fast response\n            const wheelSensitivity = Math.abs(e.deltaY) / 50 // Increased sensitivity\n            ;\n            const baseZoomFactor = e.deltaY > 0 ? 0.8 : 1.25 // More aggressive base zoom\n            ;\n            const dynamicZoomFactor = e.deltaY > 0 ? Math.max(0.3, 1 - wheelSensitivity * 0.4) // Ultra-fast zoom out\n             : Math.min(3.0, 1 + wheelSensitivity * 0.5) // Ultra-fast zoom in\n            ;\n            // Axis-specific zooming\n            if (axisZone === 'price-axis' || axisZone === 'price-axis-edge' || e.ctrlKey || e.metaKey) {\n                // Price zoom (vertical) - ultra responsive\n                setViewportState({\n                    \"useChartInteractions.useCallback[handleWheel]\": (prev)=>({\n                            ...prev,\n                            priceZoom: Math.max(0.05, Math.min(50, prev.priceZoom * dynamicZoomFactor))\n                        })\n                }[\"useChartInteractions.useCallback[handleWheel]\"]);\n            } else if (axisZone === 'time-axis' || axisZone === 'time-axis-edge') {\n                // Time zoom (horizontal) - ultra responsive  \n                setViewportState({\n                    \"useChartInteractions.useCallback[handleWheel]\": (prev)=>({\n                            ...prev,\n                            timeZoom: Math.max(0.05, Math.min(50, prev.timeZoom * dynamicZoomFactor))\n                        })\n                }[\"useChartInteractions.useCallback[handleWheel]\"]);\n            } else {\n                // Default behavior - time zoom when no modifier\n                setViewportState({\n                    \"useChartInteractions.useCallback[handleWheel]\": (prev)=>({\n                            ...prev,\n                            timeZoom: Math.max(0.05, Math.min(50, prev.timeZoom * dynamicZoomFactor))\n                        })\n                }[\"useChartInteractions.useCallback[handleWheel]\"]);\n            }\n        }\n    }[\"useChartInteractions.useCallback[handleWheel]\"], [\n        setViewportState,\n        getAxisZone\n    ]);\n    return {\n        handleMouseMove,\n        handleCanvasMouseDown,\n        handleAxisDragEnd,\n        handleWheel\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3RyYWRpbmcvdXNlQ2hhcnRJbnRlcmFjdGlvbnMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOzs7Q0FHQyxHQUU2QztBQUMrQztBQXFCdEYsTUFBTUksdUJBQXVCO1FBQUMsRUFDbkNDLFNBQVMsRUFDVEMsVUFBVSxFQUNWQyxXQUFXLEVBQ1hDLFlBQVksRUFDWkMsb0JBQW9CLEVBQ3BCQyxhQUFhLEVBQ2JDLFNBQVMsRUFDVEMsZ0JBQWdCLEVBQ2hCQyxnQkFBZ0IsRUFDaEJDLGVBQWUsRUFDZkMsdUJBQXVCLEVBQ3ZCQyxjQUFjLEVBQ2RDLHNCQUFzQixFQUN0QkMsWUFBWSxFQUNaQyxnQkFBZ0IsRUFDVTtJQUUxQjs7R0FFQyxHQUNELE1BQU1DLGNBQWNwQixrREFBV0E7eURBQUMsQ0FBQ3FCLEdBQVdDLEdBQVdDO1lBQ3JELE1BQU1DLE9BQU9ELE9BQU9FLHFCQUFxQjtZQUN6QyxNQUFNQyxpQkFBaUIsR0FBRyxzQ0FBc0M7O1lBQ2hFLE1BQU1DLGlCQUFpQixHQUFHLGdDQUFnQzs7WUFDMUQsTUFBTUMsYUFBYUosS0FBS0ssS0FBSyxHQUFHSDtZQUNoQyxNQUFNSSxjQUFjTixLQUFLTyxNQUFNLEdBQUdKO1lBRWxDLDJDQUEyQztZQUMzQyxJQUFJTixLQUFLTyxjQUFjUCxLQUFLRyxLQUFLSyxLQUFLLEVBQUU7Z0JBQ3RDLE9BQU87WUFDVDtZQUVBLDZDQUE2QztZQUM3QyxJQUFJUCxLQUFLUSxlQUFlUixLQUFLRSxLQUFLTyxNQUFNLEVBQUU7Z0JBQ3hDLE9BQU87WUFDVDtZQUVBLHFEQUFxRDtZQUNyRCxJQUFJVixLQUFLTyxhQUFhLE1BQU1QLEtBQUtPLGFBQWEsSUFBSTtnQkFDaEQsT0FBTztZQUNUO1lBRUEsb0RBQW9EO1lBQ3BELElBQUlOLEtBQUtRLGNBQWMsTUFBTVIsS0FBS1EsY0FBYyxJQUFJO2dCQUNsRCxPQUFPO1lBQ1Q7WUFFQSxPQUFPO1FBQ1Q7d0RBQUcsRUFBRTtJQUVMOztHQUVD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RiwyQ0FBMkM7Z0JBQzNDckY7cUVBQWlCeUIsQ0FBQUEsT0FBUzs0QkFDeEIsR0FBR0EsSUFBSTs0QkFDUEMsV0FBV0MsS0FBS0MsR0FBRyxDQUFDLE1BQU1ELEtBQUtFLEdBQUcsQ0FBQyxJQUFJSixLQUFLQyxTQUFTLEdBQUd5RDt3QkFDMUQ7O1lBQ0YsT0FBTyxJQUFJakQsYUFBYSxlQUFlQSxhQUFhLGtCQUFrQjtnQkFDcEUsOENBQThDO2dCQUM5Q2xDO3FFQUFpQnlCLENBQUFBLE9BQVM7NEJBQ3hCLEdBQUdBLElBQUk7NEJBQ1BPLFVBQVVMLEtBQUtDLEdBQUcsQ0FBQyxNQUFNRCxLQUFLRSxHQUFHLENBQUMsSUFBSUosS0FBS08sUUFBUSxHQUFHbUQ7d0JBQ3hEOztZQUNGLE9BQU87Z0JBQ0wsZ0RBQWdEO2dCQUNoRG5GO3FFQUFpQnlCLENBQUFBLE9BQVM7NEJBQ3hCLEdBQUdBLElBQUk7NEJBQ1BPLFVBQVVMLEtBQUtDLEdBQUcsQ0FBQyxNQUFNRCxLQUFLRSxHQUFHLENBQUMsSUFBSUosS0FBS08sUUFBUSxHQUFHbUQ7d0JBQ3hEOztZQUNGO1FBQ0Y7d0RBQUc7UUFBQ25GO1FBQWtCQztLQUFZO0lBRWxDLE9BQU87UUFDTFk7UUFDQW1DO1FBQ0F1QjtRQUNBUztJQUNGO0FBQ0YsRUFBQyIsInNvdXJjZXMiOlsiL1VzZXJzL21zbi9wcm9qZWN0cy90dGVybWluYWwvdHRlcm1pbmFsLWZyb250ZW5kL2hvb2tzL3RyYWRpbmcvdXNlQ2hhcnRJbnRlcmFjdGlvbnMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDaGFydCBJbnRlcmFjdGlvbnMgSG9va1xuICogTWFuYWdlcyBtb3VzZSBldmVudHMsIGRyYXdpbmcgdG9vbHMsIGFuZCBjaGFydCBpbnRlcmFjdGlvbnMgd2l0aCB1bHRyYS1mYXN0IGF4aXMtc3BlY2lmaWMgem9vbVxuICovXG5cbmltcG9ydCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IHNjcmVlblRvQ2hhcnRDb29yZGluYXRlcywgaXNQb2ludEluRHJhd2luZyB9IGZyb20gJy4uLy4uL3V0aWxzL3RyYWRpbmcvY2FsY3VsYXRpb25zJ1xuaW1wb3J0IHR5cGUgeyBDYW5kbGVEYXRhLCBEcmF3aW5nLCBWaWV3cG9ydFN0YXRlLCBEcmFnU3RhdGUgfSBmcm9tICcuLi8uLi90eXBlcy90cmFkaW5nJ1xuXG5pbnRlcmZhY2UgVXNlQ2hhcnRJbnRlcmFjdGlvbnNQcm9wcyB7XG4gIGNhbnZhc1JlZjogUmVhY3QuUmVmT2JqZWN0PEhUTUxDYW52YXNFbGVtZW50IHwgbnVsbD5cbiAgY2FuZGxlRGF0YTogQ2FuZGxlRGF0YVtdXG4gIGRyYXdpbmdNb2RlOiBzdHJpbmcgfCBudWxsXG4gIGRyYXdpbmdUb29sczogRHJhd2luZ1tdXG4gIHNlbGVjdGVkRHJhd2luZ0luZGV4OiBudW1iZXIgfCBudWxsXG4gIHZpZXdwb3J0U3RhdGU6IFZpZXdwb3J0U3RhdGVcbiAgZHJhZ1N0YXRlOiBEcmFnU3RhdGVcbiAgc2V0SG92ZXJlZENhbmRsZTogKGNhbmRsZTogQ2FuZGxlRGF0YSB8IG51bGwpID0+IHZvaWRcbiAgc2V0TW91c2VQb3NpdGlvbjogKHBvczogYW55KSA9PiB2b2lkXG4gIHNldERyYXdpbmdUb29sczogKHRvb2xzOiBEcmF3aW5nW10gfCAoKHByZXY6IERyYXdpbmdbXSkgPT4gRHJhd2luZ1tdKSkgPT4gdm9pZFxuICBzZXRTZWxlY3RlZERyYXdpbmdJbmRleDogKGluZGV4OiBudW1iZXIgfCBudWxsKSA9PiB2b2lkXG4gIHNldERyYXdpbmdNb2RlOiAobW9kZTogc3RyaW5nIHwgbnVsbCkgPT4gdm9pZFxuICBzZXRTZWxlY3RlZERyYXdpbmdUb29sOiAodG9vbDogc3RyaW5nIHwgbnVsbCkgPT4gdm9pZFxuICBzZXREcmFnU3RhdGU6IChzdGF0ZTogRHJhZ1N0YXRlIHwgKChwcmV2OiBEcmFnU3RhdGUpID0+IERyYWdTdGF0ZSkpID0+IHZvaWRcbiAgc2V0Vmlld3BvcnRTdGF0ZTogKHN0YXRlOiBWaWV3cG9ydFN0YXRlIHwgKChwcmV2OiBWaWV3cG9ydFN0YXRlKSA9PiBWaWV3cG9ydFN0YXRlKSkgPT4gdm9pZFxufVxuXG5leHBvcnQgY29uc3QgdXNlQ2hhcnRJbnRlcmFjdGlvbnMgPSAoe1xuICBjYW52YXNSZWYsXG4gIGNhbmRsZURhdGEsXG4gIGRyYXdpbmdNb2RlLFxuICBkcmF3aW5nVG9vbHMsXG4gIHNlbGVjdGVkRHJhd2luZ0luZGV4LFxuICB2aWV3cG9ydFN0YXRlLFxuICBkcmFnU3RhdGUsXG4gIHNldEhvdmVyZWRDYW5kbGUsXG4gIHNldE1vdXNlUG9zaXRpb24sXG4gIHNldERyYXdpbmdUb29scyxcbiAgc2V0U2VsZWN0ZWREcmF3aW5nSW5kZXgsXG4gIHNldERyYXdpbmdNb2RlLFxuICBzZXRTZWxlY3RlZERyYXdpbmdUb29sLFxuICBzZXREcmFnU3RhdGUsXG4gIHNldFZpZXdwb3J0U3RhdGUsXG59OiBVc2VDaGFydEludGVyYWN0aW9uc1Byb3BzKSA9PiB7XG5cbiAgLyoqXG4gICAqIERldGVjdCBpZiBtb3VzZSBpcyBvdmVyIFktYXhpcyAocHJpY2UgYXhpcykgb3IgWC1heGlzICh0aW1lIGF4aXMpXG4gICAqL1xuICBjb25zdCBnZXRBeGlzWm9uZSA9IHVzZUNhbGxiYWNrKCh4OiBudW1iZXIsIHk6IG51bWJlciwgY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkgPT4ge1xuICAgIGNvbnN0IHJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICBjb25zdCBwcmljZUF4aXNXaWR0aCA9IDgwIC8vIFJpZ2h0IHNpZGUgcHJpY2UgYXhpcyAody0yMCA9IDgwcHgpXG4gICAgY29uc3QgdGltZUF4aXNIZWlnaHQgPSAzMiAvLyBCb3R0b20gdGltZSBheGlzIChoLTggPSAzMnB4KVxuICAgIGNvbnN0IGNoYXJ0V2lkdGggPSByZWN0LndpZHRoIC0gcHJpY2VBeGlzV2lkdGhcbiAgICBjb25zdCBjaGFydEhlaWdodCA9IHJlY3QuaGVpZ2h0IC0gdGltZUF4aXNIZWlnaHRcbiAgICBcbiAgICAvLyBDaGVjayBpZiBpbiBwcmljZSBheGlzIHpvbmUgKHJpZ2h0IGVkZ2UpXG4gICAgaWYgKHggPj0gY2hhcnRXaWR0aCAmJiB4IDw9IHJlY3Qud2lkdGgpIHtcbiAgICAgIHJldHVybiAncHJpY2UtYXhpcydcbiAgICB9XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgaW4gdGltZSBheGlzIHpvbmUgKGJvdHRvbSBlZGdlKSAgXG4gICAgaWYgKHkgPj0gY2hhcnRIZWlnaHQgJiYgeSA8PSByZWN0LmhlaWdodCkge1xuICAgICAgcmV0dXJuICd0aW1lLWF4aXMnXG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGlmIG5lYXIgcHJpY2UgYXhpcyBlZGdlIChmb3IgZHJhZyBkZXRlY3Rpb24pXG4gICAgaWYgKHggPj0gY2hhcnRXaWR0aCAtIDE1ICYmIHggPD0gY2hhcnRXaWR0aCArIDE1KSB7XG4gICAgICByZXR1cm4gJ3ByaWNlLWF4aXMtZWRnZSdcbiAgICB9XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgbmVhciB0aW1lIGF4aXMgZWRnZSAoZm9yIGRyYWcgZGV0ZWN0aW9uKVxuICAgIGlmICh5ID49IGNoYXJ0SGVpZ2h0IC0gMTUgJiYgeSA8PSBjaGFydEhlaWdodCArIDE1KSB7XG4gICAgICByZXR1cm4gJ3RpbWUtYXhpcy1lZGdlJ1xuICAgIH1cbiAgICBcbiAgICByZXR1cm4gJ2NoYXJ0J1xuICB9LCBbXSlcblxuICAvKipcbiAgICogSGFuZGxlIG1vdXNlIG1vdmVtZW50IGZvciBjcm9zc2hhaXIsIGNhbmRsZSBob3ZlciwgYW5kIGF4aXMgZGV0ZWN0aW9uXG4gICAqL1xuICBjb25zdCBoYW5kbGVNb3VzZU1vdmUgPSB1c2VDYWxsYmFjayhcbiAgICAoZXZlbnQ6IFJlYWN0Lk1vdXNlRXZlbnQ8SFRNTENhbnZhc0VsZW1lbnQ+KSA9PiB7XG4gICAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudFxuICAgICAgaWYgKCFjYW52YXMpIHJldHVyblxuXG4gICAgICBjb25zdCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICBjb25zdCB4ID0gZXZlbnQuY2xpZW50WCAtIHJlY3QubGVmdFxuICAgICAgY29uc3QgeSA9IGV2ZW50LmNsaWVudFkgLSByZWN0LnRvcFxuXG4gICAgICAvLyBIYW5kbGUgYWN0aXZlIGF4aXMgZHJhZ2dpbmcgb25seVxuICAgICAgaWYgKGRyYWdTdGF0ZS5pc0RyYWdnaW5nUHJpY2UpIHtcbiAgICAgICAgY29uc3QgZGVsdGFZID0geSAtIGRyYWdTdGF0ZS5kcmFnU3RhcnQueVxuICAgICAgICBjb25zdCBzZW5zaXRpdml0eSA9IDAuMDAyIC8vIFVsdHJhLXNlbnNpdGl2ZSBmb3IgcHJvZmVzc2lvbmFsIHRyYWRpbmdcbiAgICAgICAgY29uc3Qgem9vbUZhY3RvciA9IDEgKyAoZGVsdGFZICogc2Vuc2l0aXZpdHkpXG4gICAgICAgIFxuICAgICAgICBzZXRWaWV3cG9ydFN0YXRlKHByZXYgPT4gKHtcbiAgICAgICAgICAuLi5wcmV2LFxuICAgICAgICAgIHByaWNlWm9vbTogTWF0aC5tYXgoMC4wNSwgTWF0aC5taW4oNTAsIHByZXYucHJpY2Vab29tICogem9vbUZhY3RvcikpXG4gICAgICAgIH0pKVxuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIGRyYWcgc3RhcnQgZm9yIGNvbnRpbnVvdXMgbW92ZW1lbnRcbiAgICAgICAgc2V0RHJhZ1N0YXRlKHByZXYgPT4gKHsgLi4ucHJldiwgZHJhZ1N0YXJ0OiB7IHgsIHkgfSB9KSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmIChkcmFnU3RhdGUuaXNEcmFnZ2luZ1RpbWUpIHtcbiAgICAgICAgY29uc3QgZGVsdGFYID0geCAtIGRyYWdTdGF0ZS5kcmFnU3RhcnQueFxuICAgICAgICBjb25zdCBzZW5zaXRpdml0eSA9IDAuMDAyIC8vIFVsdHJhLXNlbnNpdGl2ZSBmb3IgcHJvZmVzc2lvbmFsIHRyYWRpbmdcbiAgICAgICAgY29uc3Qgem9vbUZhY3RvciA9IDEgKyAoZGVsdGFYICogc2Vuc2l0aXZpdHkpXG4gICAgICAgIFxuICAgICAgICBzZXRWaWV3cG9ydFN0YXRlKHByZXYgPT4gKHtcbiAgICAgICAgICAuLi5wcmV2LFxuICAgICAgICAgIHRpbWVab29tOiBNYXRoLm1heCgwLjA1LCBNYXRoLm1pbig1MCwgcHJldi50aW1lWm9vbSAqIHpvb21GYWN0b3IpKVxuICAgICAgICB9KSlcbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBkcmFnIHN0YXJ0IGZvciBjb250aW51b3VzIG1vdmVtZW50XG4gICAgICAgIHNldERyYWdTdGF0ZShwcmV2ID0+ICh7IC4uLnByZXYsIGRyYWdTdGFydDogeyB4LCB5IH0gfSkpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICAvLyBEb24ndCBpbnRlcmZlcmUgd2l0aCBleGlzdGluZyBjaGFydCBkcmFnZ2luZyAtIGxldCB0cmFkaW5nIHRlcm1pbmFsIGhhbmRsZSBpdFxuICAgICAgaWYgKGRyYWdTdGF0ZS5pc0RyYWdnaW5nQ2hhcnQpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIERldGVjdCBheGlzIHpvbmVzIGFuZCB1cGRhdGUgY3Vyc29yXG4gICAgICBjb25zdCBheGlzWm9uZSA9IGdldEF4aXNab25lKHgsIHksIGNhbnZhcylcbiAgICAgIGlmIChheGlzWm9uZSA9PT0gJ3ByaWNlLWF4aXMnIHx8IGF4aXNab25lID09PSAncHJpY2UtYXhpcy1lZGdlJykge1xuICAgICAgICBjYW52YXMuc3R5bGUuY3Vyc29yID0gJ25zLXJlc2l6ZSdcbiAgICAgIH0gZWxzZSBpZiAoYXhpc1pvbmUgPT09ICd0aW1lLWF4aXMnIHx8IGF4aXNab25lID09PSAndGltZS1heGlzLWVkZ2UnKSB7XG4gICAgICAgIGNhbnZhcy5zdHlsZS5jdXJzb3IgPSAnZXctcmVzaXplJ1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FudmFzLnN0eWxlLmN1cnNvciA9ICdtb3ZlJ1xuICAgICAgfVxuXG4gICAgICAvLyBDYWxjdWxhdGUgd2hpY2ggY2FuZGxlIGlzIGJlaW5nIGhvdmVyZWRcbiAgICAgIGNvbnN0IGNhbmRsZVdpZHRoID0gOCAqIHZpZXdwb3J0U3RhdGUudGltZVpvb21cbiAgICAgIGNvbnN0IHNwYWNpbmcgPSAxMiAqIHZpZXdwb3J0U3RhdGUudGltZVpvb21cbiAgICAgIGNvbnN0IHN0YXJ0WCA9IDUwXG4gICAgICBjb25zdCBjYW5kbGVJbmRleCA9IE1hdGguZmxvb3IoKHggLSBzdGFydFggKyB2aWV3cG9ydFN0YXRlLnRpbWVPZmZzZXQpIC8gc3BhY2luZylcblxuICAgICAgaWYgKGNhbmRsZUluZGV4ID49IDAgJiYgY2FuZGxlSW5kZXggPCBjYW5kbGVEYXRhLmxlbmd0aCkge1xuICAgICAgICBzZXRIb3ZlcmVkQ2FuZGxlKGNhbmRsZURhdGFbY2FuZGxlSW5kZXhdKVxuICAgICAgfVxuXG4gICAgICAvLyBDYWxjdWxhdGUgcHJpY2UgYXQgbW91c2UgcG9zaXRpb25cbiAgICAgIGNvbnN0IGNoYXJ0SGVpZ2h0ID0gY2FudmFzLm9mZnNldEhlaWdodCAtIDEwMFxuICAgICAgY29uc3QgcHJpY2VSYW5nZSA9ICgxMTMwMDAgLSAxMDcwMDApIC8gdmlld3BvcnRTdGF0ZS5wcmljZVpvb21cbiAgICAgIGNvbnN0IHByaWNlID0gMTEzMDAwIC0gKCh5IC0gNTAgKyB2aWV3cG9ydFN0YXRlLnByaWNlT2Zmc2V0KSAvIGNoYXJ0SGVpZ2h0KSAqIHByaWNlUmFuZ2VcblxuICAgICAgc2V0TW91c2VQb3NpdGlvbih7IHgsIHksIHByaWNlIH0pXG4gICAgfSxcbiAgICBbdmlld3BvcnRTdGF0ZSwgY2FuZGxlRGF0YSwgZHJhZ1N0YXRlLCBzZXRIb3ZlcmVkQ2FuZGxlLCBzZXRNb3VzZVBvc2l0aW9uLCBzZXRWaWV3cG9ydFN0YXRlLCBzZXREcmFnU3RhdGUsIGdldEF4aXNab25lXVxuICApXG5cbiAgLyoqXG4gICAqIEhhbmRsZSBtb3VzZSBkb3duIGV2ZW50cyBmb3IgYXhpcyBkcmFnZ2luZyBvbmx5XG4gICAqL1xuICBjb25zdCBoYW5kbGVDYW52YXNNb3VzZURvd24gPSB1c2VDYWxsYmFjaygoZTogUmVhY3QuTW91c2VFdmVudDxIVE1MQ2FudmFzRWxlbWVudD4pID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBjYW52YXNSZWYuY3VycmVudFxuICAgIGlmICghY2FudmFzKSByZXR1cm5cblxuICAgIGNvbnN0IHJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICBjb25zdCB4ID0gZS5jbGllbnRYIC0gcmVjdC5sZWZ0XG4gICAgY29uc3QgeSA9IGUuY2xpZW50WSAtIHJlY3QudG9wXG5cbiAgICAvLyBDaGVjayBmb3IgYXhpcyBkcmFnZ2luZyBmaXJzdCAtIHRoaXMgdGFrZXMgcHJpb3JpdHlcbiAgICBjb25zdCBheGlzWm9uZSA9IGdldEF4aXNab25lKHgsIHksIGNhbnZhcylcbiAgICBcbiAgICBpZiAoYXhpc1pvbmUgPT09ICdwcmljZS1heGlzJyB8fCBheGlzWm9uZSA9PT0gJ3ByaWNlLWF4aXMtZWRnZScpIHtcbiAgICAgIHNldERyYWdTdGF0ZShwcmV2ID0+ICh7XG4gICAgICAgIC4uLnByZXYsXG4gICAgICAgIGlzRHJhZ2dpbmdQcmljZTogdHJ1ZSxcbiAgICAgICAgZHJhZ1N0YXJ0OiB7IHgsIHkgfVxuICAgICAgfSkpXG4gICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBcbiAgICBpZiAoYXhpc1pvbmUgPT09ICd0aW1lLWF4aXMnIHx8IGF4aXNab25lID09PSAndGltZS1heGlzLWVkZ2UnKSB7XG4gICAgICBzZXREcmFnU3RhdGUocHJldiA9PiAoe1xuICAgICAgICAuLi5wcmV2LFxuICAgICAgICBpc0RyYWdnaW5nVGltZTogdHJ1ZSxcbiAgICAgICAgZHJhZ1N0YXJ0OiB7IHgsIHkgfVxuICAgICAgfSkpXG4gICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKClcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIEZvciBjaGFydCBhcmVhLCBsZXQgdGhlIGV4aXN0aW5nIGRyYXdpbmcgYW5kIGNoYXJ0IGRyYWcgc3lzdGVtIGhhbmRsZSBpdFxuICAgIGNvbnN0IHsgdGltZUluZGV4LCBwcmljZSB9ID0gc2NyZWVuVG9DaGFydENvb3JkaW5hdGVzKFxuICAgICAgeCwgeSwgY2FudmFzLCBcbiAgICAgIHZpZXdwb3J0U3RhdGUudGltZVpvb20sIFxuICAgICAgdmlld3BvcnRTdGF0ZS5wcmljZVpvb20sXG4gICAgICB2aWV3cG9ydFN0YXRlLnRpbWVPZmZzZXQsIFxuICAgICAgdmlld3BvcnRTdGF0ZS5wcmljZU9mZnNldFxuICAgIClcblxuICAgIC8vIEZpbmQgY2xpY2tlZCBkcmF3aW5nXG4gICAgbGV0IGNsaWNrZWREcmF3aW5nSW5kZXggPSAtMVxuICAgIGxldCBjbG9zZXN0RGlzdGFuY2UgPSBJbmZpbml0eVxuXG4gICAgZHJhd2luZ1Rvb2xzLmZvckVhY2goKHRvb2wsIGluZGV4KSA9PiB7XG4gICAgICBpZiAoaXNQb2ludEluRHJhd2luZyh0aW1lSW5kZXgsIHByaWNlLCB0b29sKSkge1xuICAgICAgICBpZiAodG9vbC50eXBlID09PSBcIkhvcml6b250YWwgUmF5XCIpIHtcbiAgICAgICAgICBjb25zdCBkaXN0YW5jZSA9IE1hdGguYWJzKHByaWNlIC0gdG9vbC5wcmljZTEpXG4gICAgICAgICAgaWYgKGRpc3RhbmNlIDwgY2xvc2VzdERpc3RhbmNlKSB7XG4gICAgICAgICAgICBjbG9zZXN0RGlzdGFuY2UgPSBkaXN0YW5jZVxuICAgICAgICAgICAgY2xpY2tlZERyYXdpbmdJbmRleCA9IGluZGV4XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNsaWNrZWREcmF3aW5nSW5kZXggPSBpbmRleFxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIFJpZ2h0LWNsaWNrIHRvIHJlbW92ZSBkcmF3aW5nc1xuICAgIGlmIChlLmJ1dHRvbiA9PT0gMikge1xuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICBpZiAoY2xpY2tlZERyYXdpbmdJbmRleCAhPT0gLTEpIHtcbiAgICAgICAgc2V0RHJhd2luZ1Rvb2xzKChwcmV2KSA9PiB7XG4gICAgICAgICAgY29uc3QgdXBkYXRlZFRvb2xzID0gWy4uLnByZXZdXG4gICAgICAgICAgdXBkYXRlZFRvb2xzLnNwbGljZShjbGlja2VkRHJhd2luZ0luZGV4LCAxKVxuICAgICAgICAgIHJldHVybiB1cGRhdGVkVG9vbHNcbiAgICAgICAgfSlcbiAgICAgICAgc2V0U2VsZWN0ZWREcmF3aW5nSW5kZXgobnVsbClcbiAgICAgIH1cbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIExlZnQtY2xpY2sgdG8gc2VsZWN0IGRyYXdpbmcgb3Igc3RhcnQgbmV3IGRyYXdpbmdcbiAgICBpZiAoY2xpY2tlZERyYXdpbmdJbmRleCAhPT0gLTEpIHtcbiAgICAgIHNldFNlbGVjdGVkRHJhd2luZ0luZGV4KGNsaWNrZWREcmF3aW5nSW5kZXgpXG4gICAgICByZXR1cm5cbiAgICB9IGVsc2Uge1xuICAgICAgc2V0U2VsZWN0ZWREcmF3aW5nSW5kZXgobnVsbClcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgZHJhd2luZyBtb2RlXG4gICAgaWYgKGRyYXdpbmdNb2RlID09PSBcIkhvcml6b250YWwgUmF5XCIpIHtcbiAgICAgIHNldERyYXdpbmdUb29scygocHJldikgPT4gW1xuICAgICAgICAuLi5wcmV2LFxuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJIb3Jpem9udGFsIFJheVwiLFxuICAgICAgICAgIHByaWNlMTogcHJpY2UsXG4gICAgICAgICAgdGltZTE6IDAsXG4gICAgICAgICAgcHJpY2UyOiBwcmljZSxcbiAgICAgICAgICB0aW1lMjogY2FuZGxlRGF0YS5sZW5ndGgsXG4gICAgICAgICAgY29sb3I6IFwiI2ZmZmYwMFwiLFxuICAgICAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgICAgfSxcbiAgICAgIF0pXG4gICAgICBzZXREcmF3aW5nTW9kZShudWxsKVxuICAgICAgc2V0U2VsZWN0ZWREcmF3aW5nVG9vbChudWxsKVxuICAgIH0gZWxzZSBpZiAoZHJhd2luZ01vZGUgPT09IFwiUmVjdGFuZ2xlXCIpIHtcbiAgICAgIHNldERyYXdpbmdUb29scygocHJldikgPT4gW1xuICAgICAgICAuLi5wcmV2LFxuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJSZWN0YW5nbGVcIixcbiAgICAgICAgICBwcmljZTE6IHByaWNlLFxuICAgICAgICAgIHRpbWUxOiB0aW1lSW5kZXgsXG4gICAgICAgICAgcHJpY2UyOiBwcmljZSxcbiAgICAgICAgICB0aW1lMjogdGltZUluZGV4LFxuICAgICAgICAgIGNvbG9yOiBcIiNmZmZmMDBcIixcbiAgICAgICAgICBsaW5lV2lkdGg6IDEsXG4gICAgICAgIH0sXG4gICAgICBdKVxuICAgIH1cblxuICAgIC8vIExldCB0aGUgdHJhZGluZyB0ZXJtaW5hbCBoYW5kbGUgY2hhcnQgcGFubmluZyAtIGRvbid0IHNldCBpc0RyYWdnaW5nQ2hhcnQgaGVyZVxuICB9LCBbY2FudmFzUmVmLCB2aWV3cG9ydFN0YXRlLCBkcmF3aW5nVG9vbHMsIGRyYXdpbmdNb2RlLCBjYW5kbGVEYXRhLCBzZXREcmF3aW5nVG9vbHMsIHNldFNlbGVjdGVkRHJhd2luZ0luZGV4LCBzZXREcmF3aW5nTW9kZSwgc2V0U2VsZWN0ZWREcmF3aW5nVG9vbCwgc2V0RHJhZ1N0YXRlLCBnZXRBeGlzWm9uZV0pXG5cbiAgLyoqXG4gICAqIEhhbmRsZSBtb3VzZSB1cCBldmVudHMgdG8gc3RvcCBheGlzIGRyYWdnaW5nXG4gICAqL1xuICBjb25zdCBoYW5kbGVBeGlzRHJhZ0VuZCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBzZXREcmFnU3RhdGUocHJldiA9PiAoe1xuICAgICAgLi4ucHJldixcbiAgICAgIGlzRHJhZ2dpbmdQcmljZTogZmFsc2UsXG4gICAgICBpc0RyYWdnaW5nVGltZTogZmFsc2UsXG4gICAgICBpc0RyYWdnaW5nQ2hhcnQ6IGZhbHNlLFxuICAgICAgaXNEcmFnZ2luZ09yZGVyYm9vazogZmFsc2UsXG4gICAgICBpc0RyYWdnaW5nQ3ZkOiBmYWxzZSxcbiAgICAgIGlzRHJhZ2dpbmdMaXF1aWRhdGlvbnM6IGZhbHNlXG4gICAgfSkpXG4gIH0sIFtzZXREcmFnU3RhdGVdKVxuXG4gIC8qKlxuICAgKiBIYW5kbGUga2V5Ym9hcmQgc2hvcnRjdXRzIGZvciBkcmF3aW5nIG1hbmFnZW1lbnRcbiAgICovXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaGFuZGxlS2V5RG93biA9IChldmVudDogS2V5Ym9hcmRFdmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0RlbGV0ZScgfHwgZXZlbnQua2V5ID09PSAnQmFja3NwYWNlJykge1xuICAgICAgICBpZiAoc2VsZWN0ZWREcmF3aW5nSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICBzZXREcmF3aW5nVG9vbHMoKHByZXYpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRUb29scyA9IFsuLi5wcmV2XVxuICAgICAgICAgICAgdXBkYXRlZFRvb2xzLnNwbGljZShzZWxlY3RlZERyYXdpbmdJbmRleCwgMSlcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVkVG9vbHNcbiAgICAgICAgICB9KVxuICAgICAgICAgIHNldFNlbGVjdGVkRHJhd2luZ0luZGV4KG51bGwpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0VzY2FwZScpIHtcbiAgICAgICAgc2V0U2VsZWN0ZWREcmF3aW5nSW5kZXgobnVsbClcbiAgICAgICAgc2V0RHJhd2luZ01vZGUobnVsbClcbiAgICAgICAgc2V0U2VsZWN0ZWREcmF3aW5nVG9vbChudWxsKVxuICAgICAgICAvLyBTdG9wIGFueSBkcmFnZ2luZ1xuICAgICAgICBzZXREcmFnU3RhdGUocHJldiA9PiAoe1xuICAgICAgICAgIC4uLnByZXYsXG4gICAgICAgICAgaXNEcmFnZ2luZ1ByaWNlOiBmYWxzZSxcbiAgICAgICAgICBpc0RyYWdnaW5nVGltZTogZmFsc2UsXG4gICAgICAgICAgaXNEcmFnZ2luZ0NoYXJ0OiBmYWxzZSxcbiAgICAgICAgICBpc0RyYWdnaW5nT3JkZXJib29rOiBmYWxzZSxcbiAgICAgICAgICBpc0RyYWdnaW5nQ3ZkOiBmYWxzZSxcbiAgICAgICAgICBpc0RyYWdnaW5nTGlxdWlkYXRpb25zOiBmYWxzZVxuICAgICAgICB9KSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlS2V5RG93bilcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZUtleURvd24pXG4gICAgfVxuICB9LCBbc2VsZWN0ZWREcmF3aW5nSW5kZXgsIHNldERyYXdpbmdUb29scywgc2V0U2VsZWN0ZWREcmF3aW5nSW5kZXgsIHNldERyYXdpbmdNb2RlLCBzZXRTZWxlY3RlZERyYXdpbmdUb29sLCBzZXREcmFnU3RhdGVdKVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgd2hlZWwgZXZlbnRzIGZvciB1bHRyYS1mYXN0IHpvb21pbmcgd2l0aCBheGlzIGRldGVjdGlvblxuICAgKi9cbiAgY29uc3QgaGFuZGxlV2hlZWwgPSB1c2VDYWxsYmFjaygoZTogV2hlZWxFdmVudCkgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIFxuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50XG4gICAgaWYgKCFjYW52YXMpIHJldHVyblxuXG4gICAgY29uc3QgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgIGNvbnN0IHggPSBlLmNsaWVudFggLSByZWN0LmxlZnRcbiAgICBjb25zdCB5ID0gZS5jbGllbnRZIC0gcmVjdC50b3BcbiAgICBcbiAgICAvLyBEZXRlY3Qgd2hpY2ggYXhpcyB3ZSdyZSBob3ZlcmluZyBvdmVyXG4gICAgY29uc3QgYXhpc1pvbmUgPSBnZXRBeGlzWm9uZSh4LCB5LCBjYW52YXMpXG4gICAgXG4gICAgLy8gVWx0cmEtYWdncmVzc2l2ZSB6b29tIGZhY3RvcnMgZm9yIGxpZ2h0bmluZy1mYXN0IHJlc3BvbnNlXG4gICAgY29uc3Qgd2hlZWxTZW5zaXRpdml0eSA9IE1hdGguYWJzKGUuZGVsdGFZKSAvIDUwIC8vIEluY3JlYXNlZCBzZW5zaXRpdml0eVxuICAgIGNvbnN0IGJhc2Vab29tRmFjdG9yID0gZS5kZWx0YVkgPiAwID8gMC44IDogMS4yNSAvLyBNb3JlIGFnZ3Jlc3NpdmUgYmFzZSB6b29tXG4gICAgY29uc3QgZHluYW1pY1pvb21GYWN0b3IgPSBlLmRlbHRhWSA+IDAgXG4gICAgICA/IE1hdGgubWF4KDAuMywgMSAtIHdoZWVsU2Vuc2l0aXZpdHkgKiAwLjQpICAvLyBVbHRyYS1mYXN0IHpvb20gb3V0XG4gICAgICA6IE1hdGgubWluKDMuMCwgMSArIHdoZWVsU2Vuc2l0aXZpdHkgKiAwLjUpICAvLyBVbHRyYS1mYXN0IHpvb20gaW5cblxuICAgIC8vIEF4aXMtc3BlY2lmaWMgem9vbWluZ1xuICAgIGlmIChheGlzWm9uZSA9PT0gJ3ByaWNlLWF4aXMnIHx8IGF4aXNab25lID09PSAncHJpY2UtYXhpcy1lZGdlJyB8fCBlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSB7XG4gICAgICAvLyBQcmljZSB6b29tICh2ZXJ0aWNhbCkgLSB1bHRyYSByZXNwb25zaXZlXG4gICAgICBzZXRWaWV3cG9ydFN0YXRlKHByZXYgPT4gKHtcbiAgICAgICAgLi4ucHJldixcbiAgICAgICAgcHJpY2Vab29tOiBNYXRoLm1heCgwLjA1LCBNYXRoLm1pbig1MCwgcHJldi5wcmljZVpvb20gKiBkeW5hbWljWm9vbUZhY3RvcikpXG4gICAgICB9KSlcbiAgICB9IGVsc2UgaWYgKGF4aXNab25lID09PSAndGltZS1heGlzJyB8fCBheGlzWm9uZSA9PT0gJ3RpbWUtYXhpcy1lZGdlJykge1xuICAgICAgLy8gVGltZSB6b29tIChob3Jpem9udGFsKSAtIHVsdHJhIHJlc3BvbnNpdmUgIFxuICAgICAgc2V0Vmlld3BvcnRTdGF0ZShwcmV2ID0+ICh7XG4gICAgICAgIC4uLnByZXYsXG4gICAgICAgIHRpbWVab29tOiBNYXRoLm1heCgwLjA1LCBNYXRoLm1pbig1MCwgcHJldi50aW1lWm9vbSAqIGR5bmFtaWNab29tRmFjdG9yKSlcbiAgICAgIH0pKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZWZhdWx0IGJlaGF2aW9yIC0gdGltZSB6b29tIHdoZW4gbm8gbW9kaWZpZXJcbiAgICAgIHNldFZpZXdwb3J0U3RhdGUocHJldiA9PiAoe1xuICAgICAgICAuLi5wcmV2LFxuICAgICAgICB0aW1lWm9vbTogTWF0aC5tYXgoMC4wNSwgTWF0aC5taW4oNTAsIHByZXYudGltZVpvb20gKiBkeW5hbWljWm9vbUZhY3RvcikpXG4gICAgICB9KSlcbiAgICB9XG4gIH0sIFtzZXRWaWV3cG9ydFN0YXRlLCBnZXRBeGlzWm9uZV0pXG5cbiAgcmV0dXJuIHtcbiAgICBoYW5kbGVNb3VzZU1vdmUsXG4gICAgaGFuZGxlQ2FudmFzTW91c2VEb3duLFxuICAgIGhhbmRsZUF4aXNEcmFnRW5kLFxuICAgIGhhbmRsZVdoZWVsLFxuICB9XG59ICJdLCJuYW1lcyI6WyJ1c2VDYWxsYmFjayIsInVzZUVmZmVjdCIsInNjcmVlblRvQ2hhcnRDb29yZGluYXRlcyIsImlzUG9pbnRJbkRyYXdpbmciLCJ1c2VDaGFydEludGVyYWN0aW9ucyIsImNhbnZhc1JlZiIsImNhbmRsZURhdGEiLCJkcmF3aW5nTW9kZSIsImRyYXdpbmdUb29scyIsInNlbGVjdGVkRHJhd2luZ0luZGV4Iiwidmlld3BvcnRTdGF0ZSIsImRyYWdTdGF0ZSIsInNldEhvdmVyZWRDYW5kbGUiLCJzZXRNb3VzZVBvc2l0aW9uIiwic2V0RHJhd2luZ1Rvb2xzIiwic2V0U2VsZWN0ZWREcmF3aW5nSW5kZXgiLCJzZXREcmF3aW5nTW9kZSIsInNldFNlbGVjdGVkRHJhd2luZ1Rvb2wiLCJzZXREcmFnU3RhdGUiLCJzZXRWaWV3cG9ydFN0YXRlIiwiZ2V0QXhpc1pvbmUiLCJ4IiwieSIsImNhbnZhcyIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJwcmljZUF4aXNXaWR0aCIsInRpbWVBeGlzSGVpZ2h0IiwiY2hhcnRXaWR0aCIsIndpZHRoIiwiY2hhcnRIZWlnaHQiLCJoZWlnaHQiLCJoYW5kbGVNb3VzZU1vdmUiLCJldmVudCIsImN1cnJlbnQiLCJjbGllbnRYIiwibGVmdCIsImNsaWVudFkiLCJ0b3AiLCJpc0RyYWdnaW5nUHJpY2UiLCJkZWx0YVkiLCJkcmFnU3RhcnQiLCJzZW5zaXRpdml0eSIsInpvb21GYWN0b3IiLCJwcmV2IiwicHJpY2Vab29tIiwiTWF0aCIsIm1heCIsIm1pbiIsImlzRHJhZ2dpbmdUaW1lIiwiZGVsdGFYIiwidGltZVpvb20iLCJpc0RyYWdnaW5nQ2hhcnQiLCJheGlzWm9uZSIsInN0eWxlIiwiY3Vyc29yIiwiY2FuZGxlV2lkdGgiLCJzcGFjaW5nIiwic3RhcnRYIiwiY2FuZGxlSW5kZXgiLCJmbG9vciIsInRpbWVPZmZzZXQiLCJsZW5ndGgiLCJvZmZzZXRIZWlnaHQiLCJwcmljZVJhbmdlIiwicHJpY2UiLCJwcmljZU9mZnNldCIsImhhbmRsZUNhbnZhc01vdXNlRG93biIsImUiLCJwcmV2ZW50RGVmYXVsdCIsInN0b3BQcm9wYWdhdGlvbiIsInRpbWVJbmRleCIsImNsaWNrZWREcmF3aW5nSW5kZXgiLCJjbG9zZXN0RGlzdGFuY2UiLCJJbmZpbml0eSIsImZvckVhY2giLCJ0b29sIiwiaW5kZXgiLCJ0eXBlIiwiZGlzdGFuY2UiLCJhYnMiLCJwcmljZTEiLCJidXR0b24iLCJ1cGRhdGVkVG9vbHMiLCJzcGxpY2UiLCJ0aW1lMSIsInByaWNlMiIsInRpbWUyIiwiY29sb3IiLCJsaW5lV2lkdGgiLCJoYW5kbGVBeGlzRHJhZ0VuZCIsImlzRHJhZ2dpbmdPcmRlcmJvb2siLCJpc0RyYWdnaW5nQ3ZkIiwiaXNEcmFnZ2luZ0xpcXVpZGF0aW9ucyIsImhhbmRsZUtleURvd24iLCJrZXkiLCJkb2N1bWVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiaGFuZGxlV2hlZWwiLCJ3aGVlbFNlbnNpdGl2aXR5IiwiYmFzZVpvb21GYWN0b3IiLCJkeW5hbWljWm9vbUZhY3RvciIsImN0cmxLZXkiLCJtZXRhS2V5Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/trading/useChartInteractions.ts\n"));

/***/ })

});