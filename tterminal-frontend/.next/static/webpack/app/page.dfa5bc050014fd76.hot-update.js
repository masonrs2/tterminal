"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./hooks/trading/useChartInteractions.ts":
/*!***********************************************!*\
  !*** ./hooks/trading/useChartInteractions.ts ***!
  \***********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useChartInteractions: () => (/* binding */ useChartInteractions)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.2.4_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils_trading_calculations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/trading/calculations */ \"(app-pages-browser)/./utils/trading/calculations.ts\");\n/**\n * Chart Interactions Hook\n * Manages mouse events, drawing tools, and chart interactions with ultra-fast axis-specific zoom\n */ \n\nconst useChartInteractions = (param)=>{\n    let { canvasRef, candleData, drawingMode, drawingTools, selectedDrawingIndex, viewportState, dragState, setHoveredCandle, setMousePosition, setDrawingTools, setSelectedDrawingIndex, setDrawingMode, setSelectedDrawingTool, setDragState, setViewportState } = param;\n    /**\n   * Detect if mouse is over Y-axis (price axis) or X-axis (time axis)\n   */ const getAxisZone = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useChartInteractions.useCallback[getAxisZone]\": (x, y, canvas)=>{\n            const priceAxisWidth = 80 // Right side price axis\n            ;\n            const timeAxisHeight = 30 // Bottom time axis\n            ;\n            const chartWidth = canvas.offsetWidth - priceAxisWidth;\n            const chartHeight = canvas.offsetHeight - timeAxisHeight;\n            // Check if in price axis zone (right edge)\n            if (x > chartWidth && x <= canvas.offsetWidth) {\n                return 'price-axis';\n            }\n            // Check if in time axis zone (bottom edge)  \n            if (y > chartHeight && y <= canvas.offsetHeight) {\n                return 'time-axis';\n            }\n            // Check if near price axis edge (for drag detection)\n            if (x > chartWidth - 10 && x <= chartWidth + 10) {\n                return 'price-axis-edge';\n            }\n            // Check if near time axis edge (for drag detection)\n            if (y > chartHeight - 10 && y <= chartHeight + 10) {\n                return 'time-axis-edge';\n            }\n            return 'chart';\n        }\n    }[\"useChartInteractions.useCallback[getAxisZone]\"], []);\n    /**\n   * Handle mouse movement for crosshair, candle hover, and axis detection\n   */ const handleMouseMove = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useChartInteractions.useCallback[handleMouseMove]\": (event)=>{\n            const canvas = canvasRef.current;\n            if (!canvas) return;\n            const rect = canvas.getBoundingClientRect();\n            const x = event.clientX - rect.left;\n            const y = event.clientY - rect.top;\n            // Handle active dragging\n            if (dragState.isDraggingPrice) {\n                const deltaY = y - dragState.dragStart.y;\n                const sensitivity = 0.001 // Ultra-sensitive for professional trading\n                ;\n                const zoomFactor = 1 + deltaY * sensitivity;\n                setViewportState({\n                    \"useChartInteractions.useCallback[handleMouseMove]\": (prev)=>({\n                            ...prev,\n                            priceZoom: Math.max(0.05, Math.min(50, prev.priceZoom * zoomFactor))\n                        })\n                }[\"useChartInteractions.useCallback[handleMouseMove]\"]);\n                // Update drag start for continuous movement\n                setDragState({\n                    \"useChartInteractions.useCallback[handleMouseMove]\": (prev)=>({\n                            ...prev,\n                            dragStart: {\n                                x,\n                                y\n                            }\n                        })\n                }[\"useChartInteractions.useCallback[handleMouseMove]\"]);\n                return;\n            }\n            if (dragState.isDraggingTime) {\n                const deltaX = x - dragState.dragStart.x;\n                const sensitivity = 0.001 // Ultra-sensitive for professional trading\n                ;\n                const zoomFactor = 1 + deltaX * sensitivity;\n                setViewportState({\n                    \"useChartInteractions.useCallback[handleMouseMove]\": (prev)=>({\n                            ...prev,\n                            timeZoom: Math.max(0.05, Math.min(50, prev.timeZoom * zoomFactor))\n                        })\n                }[\"useChartInteractions.useCallback[handleMouseMove]\"]);\n                // Update drag start for continuous movement\n                setDragState({\n                    \"useChartInteractions.useCallback[handleMouseMove]\": (prev)=>({\n                            ...prev,\n                            dragStart: {\n                                x,\n                                y\n                            }\n                        })\n                }[\"useChartInteractions.useCallback[handleMouseMove]\"]);\n                return;\n            }\n            if (dragState.isDraggingChart) {\n                const deltaX = x - dragState.dragStart.x;\n                const deltaY = y - dragState.dragStart.y;\n                setViewportState({\n                    \"useChartInteractions.useCallback[handleMouseMove]\": (prev)=>({\n                            ...prev,\n                            timeOffset: prev.timeOffset - deltaX * 2,\n                            priceOffset: prev.priceOffset - deltaY * 2\n                        })\n                }[\"useChartInteractions.useCallback[handleMouseMove]\"]);\n                // Update drag start for continuous movement\n                setDragState({\n                    \"useChartInteractions.useCallback[handleMouseMove]\": (prev)=>({\n                            ...prev,\n                            dragStart: {\n                                x,\n                                y\n                            }\n                        })\n                }[\"useChartInteractions.useCallback[handleMouseMove]\"]);\n                return;\n            }\n            // Detect axis zones and update cursor\n            const axisZone = getAxisZone(x, y, canvas);\n            if (axisZone === 'price-axis' || axisZone === 'price-axis-edge') {\n                canvas.style.cursor = 'ns-resize';\n            } else if (axisZone === 'time-axis' || axisZone === 'time-axis-edge') {\n                canvas.style.cursor = 'ew-resize';\n            } else {\n                canvas.style.cursor = 'move';\n            }\n            // Calculate which candle is being hovered\n            const candleWidth = 8 * viewportState.timeZoom;\n            const spacing = 12 * viewportState.timeZoom;\n            const startX = 50;\n            const candleIndex = Math.floor((x - startX + viewportState.timeOffset) / spacing);\n            if (candleIndex >= 0 && candleIndex < candleData.length) {\n                setHoveredCandle(candleData[candleIndex]);\n            }\n            // Calculate price at mouse position\n            const chartHeight = canvas.offsetHeight - 100;\n            const priceRange = (113000 - 107000) / viewportState.priceZoom;\n            const price = 113000 - (y - 50 + viewportState.priceOffset) / chartHeight * priceRange;\n            setMousePosition({\n                x,\n                y,\n                price\n            });\n        }\n    }[\"useChartInteractions.useCallback[handleMouseMove]\"], [\n        viewportState,\n        candleData,\n        dragState,\n        setHoveredCandle,\n        setMousePosition,\n        setViewportState,\n        setDragState,\n        getAxisZone\n    ]);\n    /**\n   * Handle mouse down events for chart interactions and axis dragging\n   */ const handleCanvasMouseDown = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useChartInteractions.useCallback[handleCanvasMouseDown]\": (e)=>{\n            const canvas = canvasRef.current;\n            if (!canvas) return;\n            const rect = canvas.getBoundingClientRect();\n            const x = e.clientX - rect.left;\n            const y = e.clientY - rect.top;\n            // Check for axis dragging first\n            const axisZone = getAxisZone(x, y, canvas);\n            if (axisZone === 'price-axis' || axisZone === 'price-axis-edge') {\n                setDragState({\n                    \"useChartInteractions.useCallback[handleCanvasMouseDown]\": (prev)=>({\n                            ...prev,\n                            isDraggingPrice: true,\n                            dragStart: {\n                                x,\n                                y\n                            }\n                        })\n                }[\"useChartInteractions.useCallback[handleCanvasMouseDown]\"]);\n                e.preventDefault();\n                return;\n            }\n            if (axisZone === 'time-axis' || axisZone === 'time-axis-edge') {\n                setDragState({\n                    \"useChartInteractions.useCallback[handleCanvasMouseDown]\": (prev)=>({\n                            ...prev,\n                            isDraggingTime: true,\n                            dragStart: {\n                                x,\n                                y\n                            }\n                        })\n                }[\"useChartInteractions.useCallback[handleCanvasMouseDown]\"]);\n                e.preventDefault();\n                return;\n            }\n            const { timeIndex, price } = (0,_utils_trading_calculations__WEBPACK_IMPORTED_MODULE_1__.screenToChartCoordinates)(x, y, canvas, viewportState.timeZoom, viewportState.priceZoom, viewportState.timeOffset, viewportState.priceOffset);\n            // Find clicked drawing\n            let clickedDrawingIndex = -1;\n            let closestDistance = Infinity;\n            drawingTools.forEach({\n                \"useChartInteractions.useCallback[handleCanvasMouseDown]\": (tool, index)=>{\n                    if ((0,_utils_trading_calculations__WEBPACK_IMPORTED_MODULE_1__.isPointInDrawing)(timeIndex, price, tool)) {\n                        if (tool.type === \"Horizontal Ray\") {\n                            const distance = Math.abs(price - tool.price1);\n                            if (distance < closestDistance) {\n                                closestDistance = distance;\n                                clickedDrawingIndex = index;\n                            }\n                        } else {\n                            clickedDrawingIndex = index;\n                        }\n                    }\n                }\n            }[\"useChartInteractions.useCallback[handleCanvasMouseDown]\"]);\n            // Right-click to remove drawings\n            if (e.button === 2) {\n                e.preventDefault();\n                if (clickedDrawingIndex !== -1) {\n                    setDrawingTools({\n                        \"useChartInteractions.useCallback[handleCanvasMouseDown]\": (prev)=>{\n                            const updatedTools = [\n                                ...prev\n                            ];\n                            updatedTools.splice(clickedDrawingIndex, 1);\n                            return updatedTools;\n                        }\n                    }[\"useChartInteractions.useCallback[handleCanvasMouseDown]\"]);\n                    setSelectedDrawingIndex(null);\n                }\n                return;\n            }\n            // Left-click to select drawing or start new drawing\n            if (clickedDrawingIndex !== -1) {\n                setSelectedDrawingIndex(clickedDrawingIndex);\n                return;\n            } else {\n                setSelectedDrawingIndex(null);\n            }\n            // Start chart dragging if not in drawing mode\n            if (!drawingMode) {\n                setDragState({\n                    \"useChartInteractions.useCallback[handleCanvasMouseDown]\": (prev)=>({\n                            ...prev,\n                            isDraggingChart: true,\n                            dragStart: {\n                                x,\n                                y\n                            }\n                        })\n                }[\"useChartInteractions.useCallback[handleCanvasMouseDown]\"]);\n                return;\n            }\n            // Handle drawing mode\n            if (drawingMode === \"Horizontal Ray\") {\n                setDrawingTools({\n                    \"useChartInteractions.useCallback[handleCanvasMouseDown]\": (prev)=>[\n                            ...prev,\n                            {\n                                type: \"Horizontal Ray\",\n                                price1: price,\n                                time1: 0,\n                                price2: price,\n                                time2: candleData.length,\n                                color: \"#ffff00\",\n                                lineWidth: 1\n                            }\n                        ]\n                }[\"useChartInteractions.useCallback[handleCanvasMouseDown]\"]);\n                setDrawingMode(null);\n                setSelectedDrawingTool(null);\n            } else if (drawingMode === \"Rectangle\") {\n                setDrawingTools({\n                    \"useChartInteractions.useCallback[handleCanvasMouseDown]\": (prev)=>[\n                            ...prev,\n                            {\n                                type: \"Rectangle\",\n                                price1: price,\n                                time1: timeIndex,\n                                price2: price,\n                                time2: timeIndex,\n                                color: \"#ffff00\",\n                                lineWidth: 1\n                            }\n                        ]\n                }[\"useChartInteractions.useCallback[handleCanvasMouseDown]\"]);\n            }\n        }\n    }[\"useChartInteractions.useCallback[handleCanvasMouseDown]\"], [\n        canvasRef,\n        viewportState,\n        drawingTools,\n        drawingMode,\n        candleData,\n        dragState,\n        setDrawingTools,\n        setSelectedDrawingIndex,\n        setDrawingMode,\n        setSelectedDrawingTool,\n        setDragState,\n        getAxisZone\n    ]);\n    /**\n   * Handle mouse up events to stop dragging\n   */ const handleCanvasMouseUp = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useChartInteractions.useCallback[handleCanvasMouseUp]\": ()=>{\n            setDragState({\n                \"useChartInteractions.useCallback[handleCanvasMouseUp]\": (prev)=>({\n                        ...prev,\n                        isDraggingPrice: false,\n                        isDraggingTime: false,\n                        isDraggingChart: false,\n                        isDraggingOrderbook: false,\n                        isDraggingCvd: false,\n                        isDraggingLiquidations: false\n                    })\n            }[\"useChartInteractions.useCallback[handleCanvasMouseUp]\"]);\n        }\n    }[\"useChartInteractions.useCallback[handleCanvasMouseUp]\"], [\n        setDragState\n    ]);\n    /**\n   * Handle keyboard shortcuts for drawing management\n   */ (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useChartInteractions.useEffect\": ()=>{\n            const handleKeyDown = {\n                \"useChartInteractions.useEffect.handleKeyDown\": (event)=>{\n                    if (event.key === 'Delete' || event.key === 'Backspace') {\n                        if (selectedDrawingIndex !== null) {\n                            setDrawingTools({\n                                \"useChartInteractions.useEffect.handleKeyDown\": (prev)=>{\n                                    const updatedTools = [\n                                        ...prev\n                                    ];\n                                    updatedTools.splice(selectedDrawingIndex, 1);\n                                    return updatedTools;\n                                }\n                            }[\"useChartInteractions.useEffect.handleKeyDown\"]);\n                            setSelectedDrawingIndex(null);\n                        }\n                    }\n                    if (event.key === 'Escape') {\n                        setSelectedDrawingIndex(null);\n                        setDrawingMode(null);\n                        setSelectedDrawingTool(null);\n                        // Stop any dragging\n                        setDragState({\n                            \"useChartInteractions.useEffect.handleKeyDown\": (prev)=>({\n                                    ...prev,\n                                    isDraggingPrice: false,\n                                    isDraggingTime: false,\n                                    isDraggingChart: false,\n                                    isDraggingOrderbook: false,\n                                    isDraggingCvd: false,\n                                    isDraggingLiquidations: false\n                                })\n                        }[\"useChartInteractions.useEffect.handleKeyDown\"]);\n                    }\n                }\n            }[\"useChartInteractions.useEffect.handleKeyDown\"];\n            document.addEventListener('keydown', handleKeyDown);\n            return ({\n                \"useChartInteractions.useEffect\": ()=>{\n                    document.removeEventListener('keydown', handleKeyDown);\n                }\n            })[\"useChartInteractions.useEffect\"];\n        }\n    }[\"useChartInteractions.useEffect\"], [\n        selectedDrawingIndex,\n        setDrawingTools,\n        setSelectedDrawingIndex,\n        setDrawingMode,\n        setSelectedDrawingTool,\n        setDragState\n    ]);\n    /**\n   * Handle wheel events for ultra-fast zooming with axis detection\n   */ const handleWheel = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useChartInteractions.useCallback[handleWheel]\": (e)=>{\n            e.preventDefault();\n            const canvas = canvasRef.current;\n            if (!canvas) return;\n            const rect = canvas.getBoundingClientRect();\n            const x = e.clientX - rect.left;\n            const y = e.clientY - rect.top;\n            // Detect which axis we're hovering over\n            const axisZone = getAxisZone(x, y, canvas);\n            // Ultra-aggressive zoom factors for lightning-fast response\n            const wheelSensitivity = Math.abs(e.deltaY) / 50 // Increased sensitivity\n            ;\n            const baseZoomFactor = e.deltaY > 0 ? 0.8 : 1.25 // More aggressive base zoom\n            ;\n            const dynamicZoomFactor = e.deltaY > 0 ? Math.max(0.3, 1 - wheelSensitivity * 0.4) // Ultra-fast zoom out\n             : Math.min(3.0, 1 + wheelSensitivity * 0.5) // Ultra-fast zoom in\n            ;\n            // Axis-specific zooming\n            if (axisZone === 'price-axis' || axisZone === 'price-axis-edge' || e.ctrlKey || e.metaKey) {\n                // Price zoom (vertical) - ultra responsive\n                setViewportState({\n                    \"useChartInteractions.useCallback[handleWheel]\": (prev)=>({\n                            ...prev,\n                            priceZoom: Math.max(0.05, Math.min(50, prev.priceZoom * dynamicZoomFactor))\n                        })\n                }[\"useChartInteractions.useCallback[handleWheel]\"]);\n            } else if (axisZone === 'time-axis' || axisZone === 'time-axis-edge') {\n                // Time zoom (horizontal) - ultra responsive  \n                setViewportState({\n                    \"useChartInteractions.useCallback[handleWheel]\": (prev)=>({\n                            ...prev,\n                            timeZoom: Math.max(0.05, Math.min(50, prev.timeZoom * dynamicZoomFactor))\n                        })\n                }[\"useChartInteractions.useCallback[handleWheel]\"]);\n            } else {\n                // Default behavior - time zoom when no modifier\n                setViewportState({\n                    \"useChartInteractions.useCallback[handleWheel]\": (prev)=>({\n                            ...prev,\n                            timeZoom: Math.max(0.05, Math.min(50, prev.timeZoom * dynamicZoomFactor))\n                        })\n                }[\"useChartInteractions.useCallback[handleWheel]\"]);\n            }\n        }\n    }[\"useChartInteractions.useCallback[handleWheel]\"], [\n        setViewportState,\n        getAxisZone\n    ]);\n    return {\n        handleMouseMove,\n        handleCanvasMouseDown,\n        handleCanvasMouseUp,\n        handleWheel\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3RyYWRpbmcvdXNlQ2hhcnRJbnRlcmFjdGlvbnMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOzs7Q0FHQyxHQUU2QztBQUMrQztBQXFCdEYsTUFBTUksdUJBQXVCO1FBQUMsRUFDbkNDLFNBQVMsRUFDVEMsVUFBVSxFQUNWQyxXQUFXLEVBQ1hDLFlBQVksRUFDWkMsb0JBQW9CLEVBQ3BCQyxhQUFhLEVBQ2JDLFNBQVMsRUFDVEMsZ0JBQWdCLEVBQ2hCQyxnQkFBZ0IsRUFDaEJDLGVBQWUsRUFDZkMsdUJBQXVCLEVBQ3ZCQyxjQUFjLEVBQ2RDLHNCQUFzQixFQUN0QkMsWUFBWSxFQUNaQyxnQkFBZ0IsRUFDVTtJQUUxQjs7R0FFQyxHQUNELE1BQU1DLGNBQWNwQixrREFBV0E7eURBQUMsQ0FBQ3FCLEdBQVdDLEdBQVdDO1lBQ3JELE1BQU1DLGlCQUFpQixHQUFHLHdCQUF3Qjs7WUFDbEQsTUFBTUMsaUJBQWlCLEdBQUcsbUJBQW1COztZQUM3QyxNQUFNQyxhQUFhSCxPQUFPSSxXQUFXLEdBQUdIO1lBQ3hDLE1BQU1JLGNBQWNMLE9BQU9NLFlBQVksR0FBR0o7WUFFMUMsMkNBQTJDO1lBQzNDLElBQUlKLElBQUlLLGNBQWNMLEtBQUtFLE9BQU9JLFdBQVcsRUFBRTtnQkFDN0MsT0FBTztZQUNUO1lBRUEsNkNBQTZDO1lBQzdDLElBQUlMLElBQUlNLGVBQWVOLEtBQUtDLE9BQU9NLFlBQVksRUFBRTtnQkFDL0MsT0FBTztZQUNUO1lBRUEscURBQXFEO1lBQ3JELElBQUlSLElBQUlLLGFBQWEsTUFBTUwsS0FBS0ssYUFBYSxJQUFJO2dCQUMvQyxPQUFPO1lBQ1Q7WUFFQSxvREFBb0Q7WUFDcEQsSUFBSUosSUFBSU0sY0FBYyxNQUFNTixLQUFLTSxjQUFjLElBQUk7Z0JBQ2pELE9BQU87WUFDVDtZQUVBLE9BQU87UUFDVDt3REFBRyxFQUFFO0lBRUw7O0dBRUMsR0FDRCxNQUFNRSxrQkFBa0I5QixrREFBV0E7NkRB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Q0FvQztRQUNBc0I7UUFDQVM7SUFDRjtBQUNGLEVBQUMiLCJzb3VyY2VzIjpbIi9Vc2Vycy9tc24vcHJvamVjdHMvdHRlcm1pbmFsL3R0ZXJtaW5hbC1mcm9udGVuZC9ob29rcy90cmFkaW5nL3VzZUNoYXJ0SW50ZXJhY3Rpb25zLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQ2hhcnQgSW50ZXJhY3Rpb25zIEhvb2tcbiAqIE1hbmFnZXMgbW91c2UgZXZlbnRzLCBkcmF3aW5nIHRvb2xzLCBhbmQgY2hhcnQgaW50ZXJhY3Rpb25zIHdpdGggdWx0cmEtZmFzdCBheGlzLXNwZWNpZmljIHpvb21cbiAqL1xuXG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnXG5pbXBvcnQgeyBzY3JlZW5Ub0NoYXJ0Q29vcmRpbmF0ZXMsIGlzUG9pbnRJbkRyYXdpbmcgfSBmcm9tICcuLi8uLi91dGlscy90cmFkaW5nL2NhbGN1bGF0aW9ucydcbmltcG9ydCB0eXBlIHsgQ2FuZGxlRGF0YSwgRHJhd2luZywgVmlld3BvcnRTdGF0ZSwgRHJhZ1N0YXRlIH0gZnJvbSAnLi4vLi4vdHlwZXMvdHJhZGluZydcblxuaW50ZXJmYWNlIFVzZUNoYXJ0SW50ZXJhY3Rpb25zUHJvcHMge1xuICBjYW52YXNSZWY6IFJlYWN0LlJlZk9iamVjdDxIVE1MQ2FudmFzRWxlbWVudCB8IG51bGw+XG4gIGNhbmRsZURhdGE6IENhbmRsZURhdGFbXVxuICBkcmF3aW5nTW9kZTogc3RyaW5nIHwgbnVsbFxuICBkcmF3aW5nVG9vbHM6IERyYXdpbmdbXVxuICBzZWxlY3RlZERyYXdpbmdJbmRleDogbnVtYmVyIHwgbnVsbFxuICB2aWV3cG9ydFN0YXRlOiBWaWV3cG9ydFN0YXRlXG4gIGRyYWdTdGF0ZTogRHJhZ1N0YXRlXG4gIHNldEhvdmVyZWRDYW5kbGU6IChjYW5kbGU6IENhbmRsZURhdGEgfCBudWxsKSA9PiB2b2lkXG4gIHNldE1vdXNlUG9zaXRpb246IChwb3M6IGFueSkgPT4gdm9pZFxuICBzZXREcmF3aW5nVG9vbHM6ICh0b29sczogRHJhd2luZ1tdIHwgKChwcmV2OiBEcmF3aW5nW10pID0+IERyYXdpbmdbXSkpID0+IHZvaWRcbiAgc2V0U2VsZWN0ZWREcmF3aW5nSW5kZXg6IChpbmRleDogbnVtYmVyIHwgbnVsbCkgPT4gdm9pZFxuICBzZXREcmF3aW5nTW9kZTogKG1vZGU6IHN0cmluZyB8IG51bGwpID0+IHZvaWRcbiAgc2V0U2VsZWN0ZWREcmF3aW5nVG9vbDogKHRvb2w6IHN0cmluZyB8IG51bGwpID0+IHZvaWRcbiAgc2V0RHJhZ1N0YXRlOiAoc3RhdGU6IERyYWdTdGF0ZSB8ICgocHJldjogRHJhZ1N0YXRlKSA9PiBEcmFnU3RhdGUpKSA9PiB2b2lkXG4gIHNldFZpZXdwb3J0U3RhdGU6IChzdGF0ZTogVmlld3BvcnRTdGF0ZSB8ICgocHJldjogVmlld3BvcnRTdGF0ZSkgPT4gVmlld3BvcnRTdGF0ZSkpID0+IHZvaWRcbn1cblxuZXhwb3J0IGNvbnN0IHVzZUNoYXJ0SW50ZXJhY3Rpb25zID0gKHtcbiAgY2FudmFzUmVmLFxuICBjYW5kbGVEYXRhLFxuICBkcmF3aW5nTW9kZSxcbiAgZHJhd2luZ1Rvb2xzLFxuICBzZWxlY3RlZERyYXdpbmdJbmRleCxcbiAgdmlld3BvcnRTdGF0ZSxcbiAgZHJhZ1N0YXRlLFxuICBzZXRIb3ZlcmVkQ2FuZGxlLFxuICBzZXRNb3VzZVBvc2l0aW9uLFxuICBzZXREcmF3aW5nVG9vbHMsXG4gIHNldFNlbGVjdGVkRHJhd2luZ0luZGV4LFxuICBzZXREcmF3aW5nTW9kZSxcbiAgc2V0U2VsZWN0ZWREcmF3aW5nVG9vbCxcbiAgc2V0RHJhZ1N0YXRlLFxuICBzZXRWaWV3cG9ydFN0YXRlLFxufTogVXNlQ2hhcnRJbnRlcmFjdGlvbnNQcm9wcykgPT4ge1xuXG4gIC8qKlxuICAgKiBEZXRlY3QgaWYgbW91c2UgaXMgb3ZlciBZLWF4aXMgKHByaWNlIGF4aXMpIG9yIFgtYXhpcyAodGltZSBheGlzKVxuICAgKi9cbiAgY29uc3QgZ2V0QXhpc1pvbmUgPSB1c2VDYWxsYmFjaygoeDogbnVtYmVyLCB5OiBudW1iZXIsIGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpID0+IHtcbiAgICBjb25zdCBwcmljZUF4aXNXaWR0aCA9IDgwIC8vIFJpZ2h0IHNpZGUgcHJpY2UgYXhpc1xuICAgIGNvbnN0IHRpbWVBeGlzSGVpZ2h0ID0gMzAgLy8gQm90dG9tIHRpbWUgYXhpc1xuICAgIGNvbnN0IGNoYXJ0V2lkdGggPSBjYW52YXMub2Zmc2V0V2lkdGggLSBwcmljZUF4aXNXaWR0aFxuICAgIGNvbnN0IGNoYXJ0SGVpZ2h0ID0gY2FudmFzLm9mZnNldEhlaWdodCAtIHRpbWVBeGlzSGVpZ2h0XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgaW4gcHJpY2UgYXhpcyB6b25lIChyaWdodCBlZGdlKVxuICAgIGlmICh4ID4gY2hhcnRXaWR0aCAmJiB4IDw9IGNhbnZhcy5vZmZzZXRXaWR0aCkge1xuICAgICAgcmV0dXJuICdwcmljZS1heGlzJ1xuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBpZiBpbiB0aW1lIGF4aXMgem9uZSAoYm90dG9tIGVkZ2UpICBcbiAgICBpZiAoeSA+IGNoYXJ0SGVpZ2h0ICYmIHkgPD0gY2FudmFzLm9mZnNldEhlaWdodCkge1xuICAgICAgcmV0dXJuICd0aW1lLWF4aXMnXG4gICAgfVxuICAgIFxuICAgIC8vIENoZWNrIGlmIG5lYXIgcHJpY2UgYXhpcyBlZGdlIChmb3IgZHJhZyBkZXRlY3Rpb24pXG4gICAgaWYgKHggPiBjaGFydFdpZHRoIC0gMTAgJiYgeCA8PSBjaGFydFdpZHRoICsgMTApIHtcbiAgICAgIHJldHVybiAncHJpY2UtYXhpcy1lZGdlJ1xuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBpZiBuZWFyIHRpbWUgYXhpcyBlZGdlIChmb3IgZHJhZyBkZXRlY3Rpb24pXG4gICAgaWYgKHkgPiBjaGFydEhlaWdodCAtIDEwICYmIHkgPD0gY2hhcnRIZWlnaHQgKyAxMCkge1xuICAgICAgcmV0dXJuICd0aW1lLWF4aXMtZWRnZSdcbiAgICB9XG4gICAgXG4gICAgcmV0dXJuICdjaGFydCdcbiAgfSwgW10pXG5cbiAgLyoqXG4gICAqIEhhbmRsZSBtb3VzZSBtb3ZlbWVudCBmb3IgY3Jvc3NoYWlyLCBjYW5kbGUgaG92ZXIsIGFuZCBheGlzIGRldGVjdGlvblxuICAgKi9cbiAgY29uc3QgaGFuZGxlTW91c2VNb3ZlID0gdXNlQ2FsbGJhY2soXG4gICAgKGV2ZW50OiBSZWFjdC5Nb3VzZUV2ZW50PEhUTUxDYW52YXNFbGVtZW50PikgPT4ge1xuICAgICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnRcbiAgICAgIGlmICghY2FudmFzKSByZXR1cm5cblxuICAgICAgY29uc3QgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgICAgY29uc3QgeCA9IGV2ZW50LmNsaWVudFggLSByZWN0LmxlZnRcbiAgICAgIGNvbnN0IHkgPSBldmVudC5jbGllbnRZIC0gcmVjdC50b3BcblxuICAgICAgLy8gSGFuZGxlIGFjdGl2ZSBkcmFnZ2luZ1xuICAgICAgaWYgKGRyYWdTdGF0ZS5pc0RyYWdnaW5nUHJpY2UpIHtcbiAgICAgICAgY29uc3QgZGVsdGFZID0geSAtIGRyYWdTdGF0ZS5kcmFnU3RhcnQueVxuICAgICAgICBjb25zdCBzZW5zaXRpdml0eSA9IDAuMDAxIC8vIFVsdHJhLXNlbnNpdGl2ZSBmb3IgcHJvZmVzc2lvbmFsIHRyYWRpbmdcbiAgICAgICAgY29uc3Qgem9vbUZhY3RvciA9IDEgKyAoZGVsdGFZICogc2Vuc2l0aXZpdHkpXG4gICAgICAgIFxuICAgICAgICBzZXRWaWV3cG9ydFN0YXRlKHByZXYgPT4gKHtcbiAgICAgICAgICAuLi5wcmV2LFxuICAgICAgICAgIHByaWNlWm9vbTogTWF0aC5tYXgoMC4wNSwgTWF0aC5taW4oNTAsIHByZXYucHJpY2Vab29tICogem9vbUZhY3RvcikpXG4gICAgICAgIH0pKVxuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIGRyYWcgc3RhcnQgZm9yIGNvbnRpbnVvdXMgbW92ZW1lbnRcbiAgICAgICAgc2V0RHJhZ1N0YXRlKHByZXYgPT4gKHsgLi4ucHJldiwgZHJhZ1N0YXJ0OiB7IHgsIHkgfSB9KSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIGlmIChkcmFnU3RhdGUuaXNEcmFnZ2luZ1RpbWUpIHtcbiAgICAgICAgY29uc3QgZGVsdGFYID0geCAtIGRyYWdTdGF0ZS5kcmFnU3RhcnQueFxuICAgICAgICBjb25zdCBzZW5zaXRpdml0eSA9IDAuMDAxIC8vIFVsdHJhLXNlbnNpdGl2ZSBmb3IgcHJvZmVzc2lvbmFsIHRyYWRpbmdcbiAgICAgICAgY29uc3Qgem9vbUZhY3RvciA9IDEgKyAoZGVsdGFYICogc2Vuc2l0aXZpdHkpXG4gICAgICAgIFxuICAgICAgICBzZXRWaWV3cG9ydFN0YXRlKHByZXYgPT4gKHtcbiAgICAgICAgICAuLi5wcmV2LFxuICAgICAgICAgIHRpbWVab29tOiBNYXRoLm1heCgwLjA1LCBNYXRoLm1pbig1MCwgcHJldi50aW1lWm9vbSAqIHpvb21GYWN0b3IpKVxuICAgICAgICB9KSlcbiAgICAgICAgXG4gICAgICAgIC8vIFVwZGF0ZSBkcmFnIHN0YXJ0IGZvciBjb250aW51b3VzIG1vdmVtZW50XG4gICAgICAgIHNldERyYWdTdGF0ZShwcmV2ID0+ICh7IC4uLnByZXYsIGRyYWdTdGFydDogeyB4LCB5IH0gfSkpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAoZHJhZ1N0YXRlLmlzRHJhZ2dpbmdDaGFydCkge1xuICAgICAgICBjb25zdCBkZWx0YVggPSB4IC0gZHJhZ1N0YXRlLmRyYWdTdGFydC54XG4gICAgICAgIGNvbnN0IGRlbHRhWSA9IHkgLSBkcmFnU3RhdGUuZHJhZ1N0YXJ0LnlcbiAgICAgICAgXG4gICAgICAgIHNldFZpZXdwb3J0U3RhdGUocHJldiA9PiAoe1xuICAgICAgICAgIC4uLnByZXYsXG4gICAgICAgICAgdGltZU9mZnNldDogcHJldi50aW1lT2Zmc2V0IC0gZGVsdGFYICogMixcbiAgICAgICAgICBwcmljZU9mZnNldDogcHJldi5wcmljZU9mZnNldCAtIGRlbHRhWSAqIDJcbiAgICAgICAgfSkpXG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgZHJhZyBzdGFydCBmb3IgY29udGludW91cyBtb3ZlbWVudFxuICAgICAgICBzZXREcmFnU3RhdGUocHJldiA9PiAoeyAuLi5wcmV2LCBkcmFnU3RhcnQ6IHsgeCwgeSB9IH0pKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gRGV0ZWN0IGF4aXMgem9uZXMgYW5kIHVwZGF0ZSBjdXJzb3JcbiAgICAgIGNvbnN0IGF4aXNab25lID0gZ2V0QXhpc1pvbmUoeCwgeSwgY2FudmFzKVxuICAgICAgaWYgKGF4aXNab25lID09PSAncHJpY2UtYXhpcycgfHwgYXhpc1pvbmUgPT09ICdwcmljZS1heGlzLWVkZ2UnKSB7XG4gICAgICAgIGNhbnZhcy5zdHlsZS5jdXJzb3IgPSAnbnMtcmVzaXplJ1xuICAgICAgfSBlbHNlIGlmIChheGlzWm9uZSA9PT0gJ3RpbWUtYXhpcycgfHwgYXhpc1pvbmUgPT09ICd0aW1lLWF4aXMtZWRnZScpIHtcbiAgICAgICAgY2FudmFzLnN0eWxlLmN1cnNvciA9ICdldy1yZXNpemUnXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYW52YXMuc3R5bGUuY3Vyc29yID0gJ21vdmUnXG4gICAgICB9XG5cbiAgICAgIC8vIENhbGN1bGF0ZSB3aGljaCBjYW5kbGUgaXMgYmVpbmcgaG92ZXJlZFxuICAgICAgY29uc3QgY2FuZGxlV2lkdGggPSA4ICogdmlld3BvcnRTdGF0ZS50aW1lWm9vbVxuICAgICAgY29uc3Qgc3BhY2luZyA9IDEyICogdmlld3BvcnRTdGF0ZS50aW1lWm9vbVxuICAgICAgY29uc3Qgc3RhcnRYID0gNTBcbiAgICAgIGNvbnN0IGNhbmRsZUluZGV4ID0gTWF0aC5mbG9vcigoeCAtIHN0YXJ0WCArIHZpZXdwb3J0U3RhdGUudGltZU9mZnNldCkgLyBzcGFjaW5nKVxuXG4gICAgICBpZiAoY2FuZGxlSW5kZXggPj0gMCAmJiBjYW5kbGVJbmRleCA8IGNhbmRsZURhdGEubGVuZ3RoKSB7XG4gICAgICAgIHNldEhvdmVyZWRDYW5kbGUoY2FuZGxlRGF0YVtjYW5kbGVJbmRleF0pXG4gICAgICB9XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBwcmljZSBhdCBtb3VzZSBwb3NpdGlvblxuICAgICAgY29uc3QgY2hhcnRIZWlnaHQgPSBjYW52YXMub2Zmc2V0SGVpZ2h0IC0gMTAwXG4gICAgICBjb25zdCBwcmljZVJhbmdlID0gKDExMzAwMCAtIDEwNzAwMCkgLyB2aWV3cG9ydFN0YXRlLnByaWNlWm9vbVxuICAgICAgY29uc3QgcHJpY2UgPSAxMTMwMDAgLSAoKHkgLSA1MCArIHZpZXdwb3J0U3RhdGUucHJpY2VPZmZzZXQpIC8gY2hhcnRIZWlnaHQpICogcHJpY2VSYW5nZVxuXG4gICAgICBzZXRNb3VzZVBvc2l0aW9uKHsgeCwgeSwgcHJpY2UgfSlcbiAgICB9LFxuICAgIFt2aWV3cG9ydFN0YXRlLCBjYW5kbGVEYXRhLCBkcmFnU3RhdGUsIHNldEhvdmVyZWRDYW5kbGUsIHNldE1vdXNlUG9zaXRpb24sIHNldFZpZXdwb3J0U3RhdGUsIHNldERyYWdTdGF0ZSwgZ2V0QXhpc1pvbmVdXG4gIClcblxuICAvKipcbiAgICogSGFuZGxlIG1vdXNlIGRvd24gZXZlbnRzIGZvciBjaGFydCBpbnRlcmFjdGlvbnMgYW5kIGF4aXMgZHJhZ2dpbmdcbiAgICovXG4gIGNvbnN0IGhhbmRsZUNhbnZhc01vdXNlRG93biA9IHVzZUNhbGxiYWNrKChlOiBSZWFjdC5Nb3VzZUV2ZW50PEhUTUxDYW52YXNFbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50XG4gICAgaWYgKCFjYW52YXMpIHJldHVyblxuXG4gICAgY29uc3QgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgIGNvbnN0IHggPSBlLmNsaWVudFggLSByZWN0LmxlZnRcbiAgICBjb25zdCB5ID0gZS5jbGllbnRZIC0gcmVjdC50b3BcblxuICAgIC8vIENoZWNrIGZvciBheGlzIGRyYWdnaW5nIGZpcnN0XG4gICAgY29uc3QgYXhpc1pvbmUgPSBnZXRBeGlzWm9uZSh4LCB5LCBjYW52YXMpXG4gICAgXG4gICAgaWYgKGF4aXNab25lID09PSAncHJpY2UtYXhpcycgfHwgYXhpc1pvbmUgPT09ICdwcmljZS1heGlzLWVkZ2UnKSB7XG4gICAgICBzZXREcmFnU3RhdGUocHJldiA9PiAoe1xuICAgICAgICAuLi5wcmV2LFxuICAgICAgICBpc0RyYWdnaW5nUHJpY2U6IHRydWUsXG4gICAgICAgIGRyYWdTdGFydDogeyB4LCB5IH1cbiAgICAgIH0pKVxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgXG4gICAgaWYgKGF4aXNab25lID09PSAndGltZS1heGlzJyB8fCBheGlzWm9uZSA9PT0gJ3RpbWUtYXhpcy1lZGdlJykge1xuICAgICAgc2V0RHJhZ1N0YXRlKHByZXYgPT4gKHtcbiAgICAgICAgLi4ucHJldixcbiAgICAgICAgaXNEcmFnZ2luZ1RpbWU6IHRydWUsXG4gICAgICAgIGRyYWdTdGFydDogeyB4LCB5IH1cbiAgICAgIH0pKVxuICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCB7IHRpbWVJbmRleCwgcHJpY2UgfSA9IHNjcmVlblRvQ2hhcnRDb29yZGluYXRlcyhcbiAgICAgIHgsIHksIGNhbnZhcywgXG4gICAgICB2aWV3cG9ydFN0YXRlLnRpbWVab29tLCBcbiAgICAgIHZpZXdwb3J0U3RhdGUucHJpY2Vab29tLFxuICAgICAgdmlld3BvcnRTdGF0ZS50aW1lT2Zmc2V0LCBcbiAgICAgIHZpZXdwb3J0U3RhdGUucHJpY2VPZmZzZXRcbiAgICApXG5cbiAgICAvLyBGaW5kIGNsaWNrZWQgZHJhd2luZ1xuICAgIGxldCBjbGlja2VkRHJhd2luZ0luZGV4ID0gLTFcbiAgICBsZXQgY2xvc2VzdERpc3RhbmNlID0gSW5maW5pdHlcblxuICAgIGRyYXdpbmdUb29scy5mb3JFYWNoKCh0b29sLCBpbmRleCkgPT4ge1xuICAgICAgaWYgKGlzUG9pbnRJbkRyYXdpbmcodGltZUluZGV4LCBwcmljZSwgdG9vbCkpIHtcbiAgICAgICAgaWYgKHRvb2wudHlwZSA9PT0gXCJIb3Jpem9udGFsIFJheVwiKSB7XG4gICAgICAgICAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLmFicyhwcmljZSAtIHRvb2wucHJpY2UxKVxuICAgICAgICAgIGlmIChkaXN0YW5jZSA8IGNsb3Nlc3REaXN0YW5jZSkge1xuICAgICAgICAgICAgY2xvc2VzdERpc3RhbmNlID0gZGlzdGFuY2VcbiAgICAgICAgICAgIGNsaWNrZWREcmF3aW5nSW5kZXggPSBpbmRleFxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjbGlja2VkRHJhd2luZ0luZGV4ID0gaW5kZXhcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyBSaWdodC1jbGljayB0byByZW1vdmUgZHJhd2luZ3NcbiAgICBpZiAoZS5idXR0b24gPT09IDIpIHtcbiAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgaWYgKGNsaWNrZWREcmF3aW5nSW5kZXggIT09IC0xKSB7XG4gICAgICAgIHNldERyYXdpbmdUb29scygocHJldikgPT4ge1xuICAgICAgICAgIGNvbnN0IHVwZGF0ZWRUb29scyA9IFsuLi5wcmV2XVxuICAgICAgICAgIHVwZGF0ZWRUb29scy5zcGxpY2UoY2xpY2tlZERyYXdpbmdJbmRleCwgMSlcbiAgICAgICAgICByZXR1cm4gdXBkYXRlZFRvb2xzXG4gICAgICAgIH0pXG4gICAgICAgIHNldFNlbGVjdGVkRHJhd2luZ0luZGV4KG51bGwpXG4gICAgICB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBMZWZ0LWNsaWNrIHRvIHNlbGVjdCBkcmF3aW5nIG9yIHN0YXJ0IG5ldyBkcmF3aW5nXG4gICAgaWYgKGNsaWNrZWREcmF3aW5nSW5kZXggIT09IC0xKSB7XG4gICAgICBzZXRTZWxlY3RlZERyYXdpbmdJbmRleChjbGlja2VkRHJhd2luZ0luZGV4KVxuICAgICAgcmV0dXJuXG4gICAgfSBlbHNlIHtcbiAgICAgIHNldFNlbGVjdGVkRHJhd2luZ0luZGV4KG51bGwpXG4gICAgfVxuXG4gICAgLy8gU3RhcnQgY2hhcnQgZHJhZ2dpbmcgaWYgbm90IGluIGRyYXdpbmcgbW9kZVxuICAgIGlmICghZHJhd2luZ01vZGUpIHtcbiAgICAgIHNldERyYWdTdGF0ZShwcmV2ID0+ICh7XG4gICAgICAgIC4uLnByZXYsXG4gICAgICAgIGlzRHJhZ2dpbmdDaGFydDogdHJ1ZSxcbiAgICAgICAgZHJhZ1N0YXJ0OiB7IHgsIHkgfVxuICAgICAgfSkpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgZHJhd2luZyBtb2RlXG4gICAgaWYgKGRyYXdpbmdNb2RlID09PSBcIkhvcml6b250YWwgUmF5XCIpIHtcbiAgICAgIHNldERyYXdpbmdUb29scygocHJldikgPT4gW1xuICAgICAgICAuLi5wcmV2LFxuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJIb3Jpem9udGFsIFJheVwiLFxuICAgICAgICAgIHByaWNlMTogcHJpY2UsXG4gICAgICAgICAgdGltZTE6IDAsXG4gICAgICAgICAgcHJpY2UyOiBwcmljZSxcbiAgICAgICAgICB0aW1lMjogY2FuZGxlRGF0YS5sZW5ndGgsXG4gICAgICAgICAgY29sb3I6IFwiI2ZmZmYwMFwiLFxuICAgICAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgICAgfSxcbiAgICAgIF0pXG4gICAgICBzZXREcmF3aW5nTW9kZShudWxsKVxuICAgICAgc2V0U2VsZWN0ZWREcmF3aW5nVG9vbChudWxsKVxuICAgIH0gZWxzZSBpZiAoZHJhd2luZ01vZGUgPT09IFwiUmVjdGFuZ2xlXCIpIHtcbiAgICAgIHNldERyYXdpbmdUb29scygocHJldikgPT4gW1xuICAgICAgICAuLi5wcmV2LFxuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogXCJSZWN0YW5nbGVcIixcbiAgICAgICAgICBwcmljZTE6IHByaWNlLFxuICAgICAgICAgIHRpbWUxOiB0aW1lSW5kZXgsXG4gICAgICAgICAgcHJpY2UyOiBwcmljZSxcbiAgICAgICAgICB0aW1lMjogdGltZUluZGV4LFxuICAgICAgICAgIGNvbG9yOiBcIiNmZmZmMDBcIixcbiAgICAgICAgICBsaW5lV2lkdGg6IDEsXG4gICAgICAgIH0sXG4gICAgICBdKVxuICAgIH1cbiAgfSwgW2NhbnZhc1JlZiwgdmlld3BvcnRTdGF0ZSwgZHJhd2luZ1Rvb2xzLCBkcmF3aW5nTW9kZSwgY2FuZGxlRGF0YSwgZHJhZ1N0YXRlLCBzZXREcmF3aW5nVG9vbHMsIHNldFNlbGVjdGVkRHJhd2luZ0luZGV4LCBzZXREcmF3aW5nTW9kZSwgc2V0U2VsZWN0ZWREcmF3aW5nVG9vbCwgc2V0RHJhZ1N0YXRlLCBnZXRBeGlzWm9uZV0pXG5cbiAgLyoqXG4gICAqIEhhbmRsZSBtb3VzZSB1cCBldmVudHMgdG8gc3RvcCBkcmFnZ2luZ1xuICAgKi9cbiAgY29uc3QgaGFuZGxlQ2FudmFzTW91c2VVcCA9IHVzZUNhbGxiYWNrKCgpID0+IHtcbiAgICBzZXREcmFnU3RhdGUocHJldiA9PiAoe1xuICAgICAgLi4ucHJldixcbiAgICAgIGlzRHJhZ2dpbmdQcmljZTogZmFsc2UsXG4gICAgICBpc0RyYWdnaW5nVGltZTogZmFsc2UsXG4gICAgICBpc0RyYWdnaW5nQ2hhcnQ6IGZhbHNlLFxuICAgICAgaXNEcmFnZ2luZ09yZGVyYm9vazogZmFsc2UsXG4gICAgICBpc0RyYWdnaW5nQ3ZkOiBmYWxzZSxcbiAgICAgIGlzRHJhZ2dpbmdMaXF1aWRhdGlvbnM6IGZhbHNlXG4gICAgfSkpXG4gIH0sIFtzZXREcmFnU3RhdGVdKVxuXG4gIC8qKlxuICAgKiBIYW5kbGUga2V5Ym9hcmQgc2hvcnRjdXRzIGZvciBkcmF3aW5nIG1hbmFnZW1lbnRcbiAgICovXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaGFuZGxlS2V5RG93biA9IChldmVudDogS2V5Ym9hcmRFdmVudCkgPT4ge1xuICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0RlbGV0ZScgfHwgZXZlbnQua2V5ID09PSAnQmFja3NwYWNlJykge1xuICAgICAgICBpZiAoc2VsZWN0ZWREcmF3aW5nSW5kZXggIT09IG51bGwpIHtcbiAgICAgICAgICBzZXREcmF3aW5nVG9vbHMoKHByZXYpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRUb29scyA9IFsuLi5wcmV2XVxuICAgICAgICAgICAgdXBkYXRlZFRvb2xzLnNwbGljZShzZWxlY3RlZERyYXdpbmdJbmRleCwgMSlcbiAgICAgICAgICAgIHJldHVybiB1cGRhdGVkVG9vbHNcbiAgICAgICAgICB9KVxuICAgICAgICAgIHNldFNlbGVjdGVkRHJhd2luZ0luZGV4KG51bGwpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIFxuICAgICAgaWYgKGV2ZW50LmtleSA9PT0gJ0VzY2FwZScpIHtcbiAgICAgICAgc2V0U2VsZWN0ZWREcmF3aW5nSW5kZXgobnVsbClcbiAgICAgICAgc2V0RHJhd2luZ01vZGUobnVsbClcbiAgICAgICAgc2V0U2VsZWN0ZWREcmF3aW5nVG9vbChudWxsKVxuICAgICAgICAvLyBTdG9wIGFueSBkcmFnZ2luZ1xuICAgICAgICBzZXREcmFnU3RhdGUocHJldiA9PiAoe1xuICAgICAgICAgIC4uLnByZXYsXG4gICAgICAgICAgaXNEcmFnZ2luZ1ByaWNlOiBmYWxzZSxcbiAgICAgICAgICBpc0RyYWdnaW5nVGltZTogZmFsc2UsXG4gICAgICAgICAgaXNEcmFnZ2luZ0NoYXJ0OiBmYWxzZSxcbiAgICAgICAgICBpc0RyYWdnaW5nT3JkZXJib29rOiBmYWxzZSxcbiAgICAgICAgICBpc0RyYWdnaW5nQ3ZkOiBmYWxzZSxcbiAgICAgICAgICBpc0RyYWdnaW5nTGlxdWlkYXRpb25zOiBmYWxzZVxuICAgICAgICB9KSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlS2V5RG93bilcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZUtleURvd24pXG4gICAgfVxuICB9LCBbc2VsZWN0ZWREcmF3aW5nSW5kZXgsIHNldERyYXdpbmdUb29scywgc2V0U2VsZWN0ZWREcmF3aW5nSW5kZXgsIHNldERyYXdpbmdNb2RlLCBzZXRTZWxlY3RlZERyYXdpbmdUb29sLCBzZXREcmFnU3RhdGVdKVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgd2hlZWwgZXZlbnRzIGZvciB1bHRyYS1mYXN0IHpvb21pbmcgd2l0aCBheGlzIGRldGVjdGlvblxuICAgKi9cbiAgY29uc3QgaGFuZGxlV2hlZWwgPSB1c2VDYWxsYmFjaygoZTogV2hlZWxFdmVudCkgPT4ge1xuICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgIFxuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50XG4gICAgaWYgKCFjYW52YXMpIHJldHVyblxuXG4gICAgY29uc3QgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgIGNvbnN0IHggPSBlLmNsaWVudFggLSByZWN0LmxlZnRcbiAgICBjb25zdCB5ID0gZS5jbGllbnRZIC0gcmVjdC50b3BcbiAgICBcbiAgICAvLyBEZXRlY3Qgd2hpY2ggYXhpcyB3ZSdyZSBob3ZlcmluZyBvdmVyXG4gICAgY29uc3QgYXhpc1pvbmUgPSBnZXRBeGlzWm9uZSh4LCB5LCBjYW52YXMpXG4gICAgXG4gICAgLy8gVWx0cmEtYWdncmVzc2l2ZSB6b29tIGZhY3RvcnMgZm9yIGxpZ2h0bmluZy1mYXN0IHJlc3BvbnNlXG4gICAgY29uc3Qgd2hlZWxTZW5zaXRpdml0eSA9IE1hdGguYWJzKGUuZGVsdGFZKSAvIDUwIC8vIEluY3JlYXNlZCBzZW5zaXRpdml0eVxuICAgIGNvbnN0IGJhc2Vab29tRmFjdG9yID0gZS5kZWx0YVkgPiAwID8gMC44IDogMS4yNSAvLyBNb3JlIGFnZ3Jlc3NpdmUgYmFzZSB6b29tXG4gICAgY29uc3QgZHluYW1pY1pvb21GYWN0b3IgPSBlLmRlbHRhWSA+IDAgXG4gICAgICA/IE1hdGgubWF4KDAuMywgMSAtIHdoZWVsU2Vuc2l0aXZpdHkgKiAwLjQpICAvLyBVbHRyYS1mYXN0IHpvb20gb3V0XG4gICAgICA6IE1hdGgubWluKDMuMCwgMSArIHdoZWVsU2Vuc2l0aXZpdHkgKiAwLjUpICAvLyBVbHRyYS1mYXN0IHpvb20gaW5cblxuICAgIC8vIEF4aXMtc3BlY2lmaWMgem9vbWluZ1xuICAgIGlmIChheGlzWm9uZSA9PT0gJ3ByaWNlLWF4aXMnIHx8IGF4aXNab25lID09PSAncHJpY2UtYXhpcy1lZGdlJyB8fCBlLmN0cmxLZXkgfHwgZS5tZXRhS2V5KSB7XG4gICAgICAvLyBQcmljZSB6b29tICh2ZXJ0aWNhbCkgLSB1bHRyYSByZXNwb25zaXZlXG4gICAgICBzZXRWaWV3cG9ydFN0YXRlKHByZXYgPT4gKHtcbiAgICAgICAgLi4ucHJldixcbiAgICAgICAgcHJpY2Vab29tOiBNYXRoLm1heCgwLjA1LCBNYXRoLm1pbig1MCwgcHJldi5wcmljZVpvb20gKiBkeW5hbWljWm9vbUZhY3RvcikpXG4gICAgICB9KSlcbiAgICB9IGVsc2UgaWYgKGF4aXNab25lID09PSAndGltZS1heGlzJyB8fCBheGlzWm9uZSA9PT0gJ3RpbWUtYXhpcy1lZGdlJykge1xuICAgICAgLy8gVGltZSB6b29tIChob3Jpem9udGFsKSAtIHVsdHJhIHJlc3BvbnNpdmUgIFxuICAgICAgc2V0Vmlld3BvcnRTdGF0ZShwcmV2ID0+ICh7XG4gICAgICAgIC4uLnByZXYsXG4gICAgICAgIHRpbWVab29tOiBNYXRoLm1heCgwLjA1LCBNYXRoLm1pbig1MCwgcHJldi50aW1lWm9vbSAqIGR5bmFtaWNab29tRmFjdG9yKSlcbiAgICAgIH0pKVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZWZhdWx0IGJlaGF2aW9yIC0gdGltZSB6b29tIHdoZW4gbm8gbW9kaWZpZXJcbiAgICAgIHNldFZpZXdwb3J0U3RhdGUocHJldiA9PiAoe1xuICAgICAgICAuLi5wcmV2LFxuICAgICAgICB0aW1lWm9vbTogTWF0aC5tYXgoMC4wNSwgTWF0aC5taW4oNTAsIHByZXYudGltZVpvb20gKiBkeW5hbWljWm9vbUZhY3RvcikpXG4gICAgICB9KSlcbiAgICB9XG4gIH0sIFtzZXRWaWV3cG9ydFN0YXRlLCBnZXRBeGlzWm9uZV0pXG5cbiAgcmV0dXJuIHtcbiAgICBoYW5kbGVNb3VzZU1vdmUsXG4gICAgaGFuZGxlQ2FudmFzTW91c2VEb3duLFxuICAgIGhhbmRsZUNhbnZhc01vdXNlVXAsXG4gICAgaGFuZGxlV2hlZWwsXG4gIH1cbn0gIl0sIm5hbWVzIjpbInVzZUNhbGxiYWNrIiwidXNlRWZmZWN0Iiwic2NyZWVuVG9DaGFydENvb3JkaW5hdGVzIiwiaXNQb2ludEluRHJhd2luZyIsInVzZUNoYXJ0SW50ZXJhY3Rpb25zIiwiY2FudmFzUmVmIiwiY2FuZGxlRGF0YSIsImRyYXdpbmdNb2RlIiwiZHJhd2luZ1Rvb2xzIiwic2VsZWN0ZWREcmF3aW5nSW5kZXgiLCJ2aWV3cG9ydFN0YXRlIiwiZHJhZ1N0YXRlIiwic2V0SG92ZXJlZENhbmRsZSIsInNldE1vdXNlUG9zaXRpb24iLCJzZXREcmF3aW5nVG9vbHMiLCJzZXRTZWxlY3RlZERyYXdpbmdJbmRleCIsInNldERyYXdpbmdNb2RlIiwic2V0U2VsZWN0ZWREcmF3aW5nVG9vbCIsInNldERyYWdTdGF0ZSIsInNldFZpZXdwb3J0U3RhdGUiLCJnZXRBeGlzWm9uZSIsIngiLCJ5IiwiY2FudmFzIiwicHJpY2VBeGlzV2lkdGgiLCJ0aW1lQXhpc0hlaWdodCIsImNoYXJ0V2lkdGgiLCJvZmZzZXRXaWR0aCIsImNoYXJ0SGVpZ2h0Iiwib2Zmc2V0SGVpZ2h0IiwiaGFuZGxlTW91c2VNb3ZlIiwiZXZlbnQiLCJjdXJyZW50IiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImNsaWVudFgiLCJsZWZ0IiwiY2xpZW50WSIsInRvcCIsImlzRHJhZ2dpbmdQcmljZSIsImRlbHRhWSIsImRyYWdTdGFydCIsInNlbnNpdGl2aXR5Iiwiem9vbUZhY3RvciIsInByZXYiLCJwcmljZVpvb20iLCJNYXRoIiwibWF4IiwibWluIiwiaXNEcmFnZ2luZ1RpbWUiLCJkZWx0YVgiLCJ0aW1lWm9vbSIsImlzRHJhZ2dpbmdDaGFydCIsInRpbWVPZmZzZXQiLCJwcmljZU9mZnNldCIsImF4aXNab25lIiwic3R5bGUiLCJjdXJzb3IiLCJjYW5kbGVXaWR0aCIsInNwYWNpbmciLCJzdGFydFgiLCJjYW5kbGVJbmRleCIsImZsb29yIiwibGVuZ3RoIiwicHJpY2VSYW5nZSIsInByaWNlIiwiaGFuZGxlQ2FudmFzTW91c2VEb3duIiwiZSIsInByZXZlbnREZWZhdWx0IiwidGltZUluZGV4IiwiY2xpY2tlZERyYXdpbmdJbmRleCIsImNsb3Nlc3REaXN0YW5jZSIsIkluZmluaXR5IiwiZm9yRWFjaCIsInRvb2wiLCJpbmRleCIsInR5cGUiLCJkaXN0YW5jZSIsImFicyIsInByaWNlMSIsImJ1dHRvbiIsInVwZGF0ZWRUb29scyIsInNwbGljZSIsInRpbWUxIiwicHJpY2UyIiwidGltZTIiLCJjb2xvciIsImxpbmVXaWR0aCIsImhhbmRsZUNhbnZhc01vdXNlVXAiLCJpc0RyYWdnaW5nT3JkZXJib29rIiwiaXNEcmFnZ2luZ0N2ZCIsImlzRHJhZ2dpbmdMaXF1aWRhdGlvbnMiLCJoYW5kbGVLZXlEb3duIiwia2V5IiwiZG9jdW1lbnQiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImhhbmRsZVdoZWVsIiwid2hlZWxTZW5zaXRpdml0eSIsImJhc2Vab29tRmFjdG9yIiwiZHluYW1pY1pvb21GYWN0b3IiLCJjdHJsS2V5IiwibWV0YUtleSJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/trading/useChartInteractions.ts\n"));

/***/ })

});