"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./hooks/trading/useChartInteractions.ts":
/*!***********************************************!*\
  !*** ./hooks/trading/useChartInteractions.ts ***!
  \***********************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useChartInteractions: () => (/* binding */ useChartInteractions)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.2.4_react-dom@19.1.0_react@19.1.0__react@19.1.0/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils_trading_calculations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/trading/calculations */ \"(app-pages-browser)/./utils/trading/calculations.ts\");\n/**\n * Chart Interactions Hook\n * Manages mouse events, drawing tools, and chart interactions with ultra-fast axis-specific zoom\n */ \n\nconst useChartInteractions = (param)=>{\n    let { canvasRef, candleData, drawingMode, drawingTools, selectedDrawingIndex, viewportState, dragState, setHoveredCandle, setMousePosition, setDrawingTools, setSelectedDrawingIndex, setDrawingMode, setSelectedDrawingTool, setDragState, setViewportState } = param;\n    /**\n   * Detect if mouse is over Y-axis (price axis) or X-axis (time axis)\n   */ const getAxisZone = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useChartInteractions.useCallback[getAxisZone]\": (x, y, canvas)=>{\n            const priceAxisWidth = 80 // Right side price axis (w-20 = 80px)\n            ;\n            const timeAxisHeight = 32 // Bottom time axis (h-8 = 32px)\n            ;\n            const chartWidth = canvas.offsetWidth - priceAxisWidth;\n            const chartHeight = canvas.offsetHeight - timeAxisHeight;\n            // Check if in price axis zone (right edge)\n            if (x > chartWidth && x <= canvas.offsetWidth) {\n                return 'price-axis';\n            }\n            // Check if in time axis zone (bottom edge)  \n            if (y > chartHeight && y <= canvas.offsetHeight) {\n                return 'time-axis';\n            }\n            // Check if near price axis edge (for drag detection)\n            if (x > chartWidth - 10 && x <= chartWidth + 10) {\n                return 'price-axis-edge';\n            }\n            // Check if near time axis edge (for drag detection)\n            if (y > chartHeight - 10 && y <= chartHeight + 10) {\n                return 'time-axis-edge';\n            }\n            return 'chart';\n        }\n    }[\"useChartInteractions.useCallback[getAxisZone]\"], []);\n    /**\n   * Handle mouse movement for crosshair, candle hover, and axis detection\n   */ const handleMouseMove = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useChartInteractions.useCallback[handleMouseMove]\": (event)=>{\n            const canvas = canvasRef.current;\n            if (!canvas) return;\n            const rect = canvas.getBoundingClientRect();\n            const x = event.clientX - rect.left;\n            const y = event.clientY - rect.top;\n            // Handle active axis dragging only\n            if (dragState.isDraggingPrice) {\n                const deltaY = y - dragState.dragStart.y;\n                const sensitivity = 0.002 // Ultra-sensitive for professional trading\n                ;\n                const zoomFactor = 1 + deltaY * sensitivity;\n                setViewportState({\n                    \"useChartInteractions.useCallback[handleMouseMove]\": (prev)=>({\n                            ...prev,\n                            priceZoom: Math.max(0.05, Math.min(50, prev.priceZoom * zoomFactor))\n                        })\n                }[\"useChartInteractions.useCallback[handleMouseMove]\"]);\n                // Update drag start for continuous movement\n                setDragState({\n                    \"useChartInteractions.useCallback[handleMouseMove]\": (prev)=>({\n                            ...prev,\n                            dragStart: {\n                                x,\n                                y\n                            }\n                        })\n                }[\"useChartInteractions.useCallback[handleMouseMove]\"]);\n                return;\n            }\n            if (dragState.isDraggingTime) {\n                const deltaX = x - dragState.dragStart.x;\n                const sensitivity = 0.002 // Ultra-sensitive for professional trading\n                ;\n                const zoomFactor = 1 + deltaX * sensitivity;\n                setViewportState({\n                    \"useChartInteractions.useCallback[handleMouseMove]\": (prev)=>({\n                            ...prev,\n                            timeZoom: Math.max(0.05, Math.min(50, prev.timeZoom * zoomFactor))\n                        })\n                }[\"useChartInteractions.useCallback[handleMouseMove]\"]);\n                // Update drag start for continuous movement\n                setDragState({\n                    \"useChartInteractions.useCallback[handleMouseMove]\": (prev)=>({\n                            ...prev,\n                            dragStart: {\n                                x,\n                                y\n                            }\n                        })\n                }[\"useChartInteractions.useCallback[handleMouseMove]\"]);\n                return;\n            }\n            // Don't interfere with existing chart dragging - let trading terminal handle it\n            if (dragState.isDraggingChart) {\n                return;\n            }\n            // Detect axis zones and update cursor\n            const axisZone = getAxisZone(x, y, canvas);\n            if (axisZone === 'price-axis' || axisZone === 'price-axis-edge') {\n                canvas.style.cursor = 'ns-resize';\n            } else if (axisZone === 'time-axis' || axisZone === 'time-axis-edge') {\n                canvas.style.cursor = 'ew-resize';\n            } else {\n                canvas.style.cursor = 'move';\n            }\n            // Calculate which candle is being hovered\n            const candleWidth = 8 * viewportState.timeZoom;\n            const spacing = 12 * viewportState.timeZoom;\n            const startX = 50;\n            const candleIndex = Math.floor((x - startX + viewportState.timeOffset) / spacing);\n            if (candleIndex >= 0 && candleIndex < candleData.length) {\n                setHoveredCandle(candleData[candleIndex]);\n            }\n            // Calculate price at mouse position\n            const chartHeight = canvas.offsetHeight - 100;\n            const priceRange = (113000 - 107000) / viewportState.priceZoom;\n            const price = 113000 - (y - 50 + viewportState.priceOffset) / chartHeight * priceRange;\n            setMousePosition({\n                x,\n                y,\n                price\n            });\n        }\n    }[\"useChartInteractions.useCallback[handleMouseMove]\"], [\n        viewportState,\n        candleData,\n        dragState,\n        setHoveredCandle,\n        setMousePosition,\n        setViewportState,\n        setDragState,\n        getAxisZone\n    ]);\n    /**\n   * Handle mouse down events for axis dragging only\n   */ const handleCanvasMouseDown = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useChartInteractions.useCallback[handleCanvasMouseDown]\": (e)=>{\n            const canvas = canvasRef.current;\n            if (!canvas) return;\n            const rect = canvas.getBoundingClientRect();\n            const x = e.clientX - rect.left;\n            const y = e.clientY - rect.top;\n            // Check for axis dragging first - this takes priority\n            const axisZone = getAxisZone(x, y, canvas);\n            if (axisZone === 'price-axis' || axisZone === 'price-axis-edge') {\n                setDragState({\n                    \"useChartInteractions.useCallback[handleCanvasMouseDown]\": (prev)=>({\n                            ...prev,\n                            isDraggingPrice: true,\n                            dragStart: {\n                                x,\n                                y\n                            }\n                        })\n                }[\"useChartInteractions.useCallback[handleCanvasMouseDown]\"]);\n                e.preventDefault();\n                e.stopPropagation();\n                return;\n            }\n            if (axisZone === 'time-axis' || axisZone === 'time-axis-edge') {\n                setDragState({\n                    \"useChartInteractions.useCallback[handleCanvasMouseDown]\": (prev)=>({\n                            ...prev,\n                            isDraggingTime: true,\n                            dragStart: {\n                                x,\n                                y\n                            }\n                        })\n                }[\"useChartInteractions.useCallback[handleCanvasMouseDown]\"]);\n                e.preventDefault();\n                e.stopPropagation();\n                return;\n            }\n            // For chart area, let the existing drawing and chart drag system handle it\n            const { timeIndex, price } = (0,_utils_trading_calculations__WEBPACK_IMPORTED_MODULE_1__.screenToChartCoordinates)(x, y, canvas, viewportState.timeZoom, viewportState.priceZoom, viewportState.timeOffset, viewportState.priceOffset);\n            // Find clicked drawing\n            let clickedDrawingIndex = -1;\n            let closestDistance = Infinity;\n            drawingTools.forEach({\n                \"useChartInteractions.useCallback[handleCanvasMouseDown]\": (tool, index)=>{\n                    if ((0,_utils_trading_calculations__WEBPACK_IMPORTED_MODULE_1__.isPointInDrawing)(timeIndex, price, tool)) {\n                        if (tool.type === \"Horizontal Ray\") {\n                            const distance = Math.abs(price - tool.price1);\n                            if (distance < closestDistance) {\n                                closestDistance = distance;\n                                clickedDrawingIndex = index;\n                            }\n                        } else {\n                            clickedDrawingIndex = index;\n                        }\n                    }\n                }\n            }[\"useChartInteractions.useCallback[handleCanvasMouseDown]\"]);\n            // Right-click to remove drawings\n            if (e.button === 2) {\n                e.preventDefault();\n                if (clickedDrawingIndex !== -1) {\n                    setDrawingTools({\n                        \"useChartInteractions.useCallback[handleCanvasMouseDown]\": (prev)=>{\n                            const updatedTools = [\n                                ...prev\n                            ];\n                            updatedTools.splice(clickedDrawingIndex, 1);\n                            return updatedTools;\n                        }\n                    }[\"useChartInteractions.useCallback[handleCanvasMouseDown]\"]);\n                    setSelectedDrawingIndex(null);\n                }\n                return;\n            }\n            // Left-click to select drawing or start new drawing\n            if (clickedDrawingIndex !== -1) {\n                setSelectedDrawingIndex(clickedDrawingIndex);\n                return;\n            } else {\n                setSelectedDrawingIndex(null);\n            }\n            // Handle drawing mode\n            if (drawingMode === \"Horizontal Ray\") {\n                setDrawingTools({\n                    \"useChartInteractions.useCallback[handleCanvasMouseDown]\": (prev)=>[\n                            ...prev,\n                            {\n                                type: \"Horizontal Ray\",\n                                price1: price,\n                                time1: 0,\n                                price2: price,\n                                time2: candleData.length,\n                                color: \"#ffff00\",\n                                lineWidth: 1\n                            }\n                        ]\n                }[\"useChartInteractions.useCallback[handleCanvasMouseDown]\"]);\n                setDrawingMode(null);\n                setSelectedDrawingTool(null);\n            } else if (drawingMode === \"Rectangle\") {\n                setDrawingTools({\n                    \"useChartInteractions.useCallback[handleCanvasMouseDown]\": (prev)=>[\n                            ...prev,\n                            {\n                                type: \"Rectangle\",\n                                price1: price,\n                                time1: timeIndex,\n                                price2: price,\n                                time2: timeIndex,\n                                color: \"#ffff00\",\n                                lineWidth: 1\n                            }\n                        ]\n                }[\"useChartInteractions.useCallback[handleCanvasMouseDown]\"]);\n            }\n        // Let the trading terminal handle chart panning - don't set isDraggingChart here\n        }\n    }[\"useChartInteractions.useCallback[handleCanvasMouseDown]\"], [\n        canvasRef,\n        viewportState,\n        drawingTools,\n        drawingMode,\n        candleData,\n        setDrawingTools,\n        setSelectedDrawingIndex,\n        setDrawingMode,\n        setSelectedDrawingTool,\n        setDragState,\n        getAxisZone\n    ]);\n    /**\n   * Handle mouse up events to stop axis dragging\n   */ const handleAxisDragEnd = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useChartInteractions.useCallback[handleAxisDragEnd]\": ()=>{\n            setDragState({\n                \"useChartInteractions.useCallback[handleAxisDragEnd]\": (prev)=>({\n                        ...prev,\n                        isDraggingPrice: false,\n                        isDraggingTime: false,\n                        isDraggingChart: false,\n                        isDraggingOrderbook: false,\n                        isDraggingCvd: false,\n                        isDraggingLiquidations: false\n                    })\n            }[\"useChartInteractions.useCallback[handleAxisDragEnd]\"]);\n        }\n    }[\"useChartInteractions.useCallback[handleAxisDragEnd]\"], [\n        setDragState\n    ]);\n    /**\n   * Handle keyboard shortcuts for drawing management\n   */ (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)({\n        \"useChartInteractions.useEffect\": ()=>{\n            const handleKeyDown = {\n                \"useChartInteractions.useEffect.handleKeyDown\": (event)=>{\n                    if (event.key === 'Delete' || event.key === 'Backspace') {\n                        if (selectedDrawingIndex !== null) {\n                            setDrawingTools({\n                                \"useChartInteractions.useEffect.handleKeyDown\": (prev)=>{\n                                    const updatedTools = [\n                                        ...prev\n                                    ];\n                                    updatedTools.splice(selectedDrawingIndex, 1);\n                                    return updatedTools;\n                                }\n                            }[\"useChartInteractions.useEffect.handleKeyDown\"]);\n                            setSelectedDrawingIndex(null);\n                        }\n                    }\n                    if (event.key === 'Escape') {\n                        setSelectedDrawingIndex(null);\n                        setDrawingMode(null);\n                        setSelectedDrawingTool(null);\n                        // Stop any dragging\n                        setDragState({\n                            \"useChartInteractions.useEffect.handleKeyDown\": (prev)=>({\n                                    ...prev,\n                                    isDraggingPrice: false,\n                                    isDraggingTime: false,\n                                    isDraggingChart: false,\n                                    isDraggingOrderbook: false,\n                                    isDraggingCvd: false,\n                                    isDraggingLiquidations: false\n                                })\n                        }[\"useChartInteractions.useEffect.handleKeyDown\"]);\n                    }\n                }\n            }[\"useChartInteractions.useEffect.handleKeyDown\"];\n            document.addEventListener('keydown', handleKeyDown);\n            return ({\n                \"useChartInteractions.useEffect\": ()=>{\n                    document.removeEventListener('keydown', handleKeyDown);\n                }\n            })[\"useChartInteractions.useEffect\"];\n        }\n    }[\"useChartInteractions.useEffect\"], [\n        selectedDrawingIndex,\n        setDrawingTools,\n        setSelectedDrawingIndex,\n        setDrawingMode,\n        setSelectedDrawingTool,\n        setDragState\n    ]);\n    /**\n   * Handle wheel events for ultra-fast zooming with axis detection\n   */ const handleWheel = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)({\n        \"useChartInteractions.useCallback[handleWheel]\": (e)=>{\n            e.preventDefault();\n            const canvas = canvasRef.current;\n            if (!canvas) return;\n            const rect = canvas.getBoundingClientRect();\n            const x = e.clientX - rect.left;\n            const y = e.clientY - rect.top;\n            // Detect which axis we're hovering over\n            const axisZone = getAxisZone(x, y, canvas);\n            // Ultra-aggressive zoom factors for lightning-fast response\n            const wheelSensitivity = Math.abs(e.deltaY) / 50 // Increased sensitivity\n            ;\n            const baseZoomFactor = e.deltaY > 0 ? 0.8 : 1.25 // More aggressive base zoom\n            ;\n            const dynamicZoomFactor = e.deltaY > 0 ? Math.max(0.3, 1 - wheelSensitivity * 0.4) // Ultra-fast zoom out\n             : Math.min(3.0, 1 + wheelSensitivity * 0.5) // Ultra-fast zoom in\n            ;\n            // Axis-specific zooming\n            if (axisZone === 'price-axis' || axisZone === 'price-axis-edge' || e.ctrlKey || e.metaKey) {\n                // Price zoom (vertical) - ultra responsive\n                setViewportState({\n                    \"useChartInteractions.useCallback[handleWheel]\": (prev)=>({\n                            ...prev,\n                            priceZoom: Math.max(0.05, Math.min(50, prev.priceZoom * dynamicZoomFactor))\n                        })\n                }[\"useChartInteractions.useCallback[handleWheel]\"]);\n            } else if (axisZone === 'time-axis' || axisZone === 'time-axis-edge') {\n                // Time zoom (horizontal) - ultra responsive  \n                setViewportState({\n                    \"useChartInteractions.useCallback[handleWheel]\": (prev)=>({\n                            ...prev,\n                            timeZoom: Math.max(0.05, Math.min(50, prev.timeZoom * dynamicZoomFactor))\n                        })\n                }[\"useChartInteractions.useCallback[handleWheel]\"]);\n            } else {\n                // Default behavior - time zoom when no modifier\n                setViewportState({\n                    \"useChartInteractions.useCallback[handleWheel]\": (prev)=>({\n                            ...prev,\n                            timeZoom: Math.max(0.05, Math.min(50, prev.timeZoom * dynamicZoomFactor))\n                        })\n                }[\"useChartInteractions.useCallback[handleWheel]\"]);\n            }\n        }\n    }[\"useChartInteractions.useCallback[handleWheel]\"], [\n        setViewportState,\n        getAxisZone\n    ]);\n    return {\n        handleMouseMove,\n        handleCanvasMouseDown,\n        handleAxisDragEnd,\n        handleWheel\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3RyYWRpbmcvdXNlQ2hhcnRJbnRlcmFjdGlvbnMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFBOzs7Q0FHQyxHQUU2QztBQUMrQztBQXFCdEYsTUFBTUksdUJBQXVCO1FBQUMsRUFDbkNDLFNBQVMsRUFDVEMsVUFBVSxFQUNWQyxXQUFXLEVBQ1hDLFlBQVksRUFDWkMsb0JBQW9CLEVBQ3BCQyxhQUFhLEVBQ2JDLFNBQVMsRUFDVEMsZ0JBQWdCLEVBQ2hCQyxnQkFBZ0IsRUFDaEJDLGVBQWUsRUFDZkMsdUJBQXVCLEVBQ3ZCQyxjQUFjLEVBQ2RDLHNCQUFzQixFQUN0QkMsWUFBWSxFQUNaQyxnQkFBZ0IsRUFDVTtJQUUxQjs7R0FFQyxHQUNELE1BQU1DLGNBQWNwQixrREFBV0E7eURBQUMsQ0FBQ3FCLEdBQVdDLEdBQVdDO1lBQ3JELE1BQU1DLGlCQUFpQixHQUFHLHNDQUFzQzs7WUFDaEUsTUFBTUMsaUJBQWlCLEdBQUcsZ0NBQWdDOztZQUMxRCxNQUFNQyxhQUFhSCxPQUFPSSxXQUFXLEdBQUdIO1lBQ3hDLE1BQU1JLGNBQWNMLE9BQU9NLFlBQVksR0FBR0o7WUFFMUMsMkNBQTJDO1lBQzNDLElBQUlKLElBQUlLLGNBQWNMLEtBQUtFLE9BQU9JLFdBQVcsRUFBRTtnQkFDN0MsT0FBTztZQUNUO1lBRUEsNkNBQTZDO1lBQzdDLElBQUlMLElBQUlNLGVBQWVOLEtBQUtDLE9BQU9NLFlBQVksRUFBRTtnQkFDL0MsT0FBTztZQUNUO1lBRUEscURBQXFEO1lBQ3JELElBQUlSLElBQUlLLGFBQWEsTUFBTUwsS0FBS0ssYUFBYSxJQUFJO2dCQUMvQyxPQUFPO1lBQ1Q7WUFFQSxvREFBb0Q7WUFDcEQsSUFBSUosSUFBSU0sY0FBYyxNQUFNTixLQUFLTSxjQUFjLElBQUk7Z0JBQ2pELE9BQU87WUFDVDtZQUVBLE9BQU87UUFDVDt3REFBRyxFQUFFO0lBRUw7O0dBRUMsR0FDRCxNQUFNRSxrQkFBa0I5QixrREFBV0E7NkRB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QSxPQUFTOzRCQUN4QixHQUFHQSxJQUFJOzRCQUNQQyxXQUFXQyxLQUFLQyxHQUFHLENBQUMsTUFBTUQsS0FBS0UsR0FBRyxDQUFDLElBQUlKLEtBQUtDLFNBQVMsR0FBR3dEO3dCQUMxRDs7WUFDRixPQUFPLElBQUloRCxhQUFhLGVBQWVBLGFBQWEsa0JBQWtCO2dCQUNwRSw4Q0FBOEM7Z0JBQzlDbEM7cUVBQWlCeUIsQ0FBQUEsT0FBUzs0QkFDeEIsR0FBR0EsSUFBSTs0QkFDUE8sVUFBVUwsS0FBS0MsR0FBRyxDQUFDLE1BQU1ELEtBQUtFLEdBQUcsQ0FBQyxJQUFJSixLQUFLTyxRQUFRLEdBQUdrRDt3QkFDeEQ7O1lBQ0YsT0FBTztnQkFDTCxnREFBZ0Q7Z0JBQ2hEbEY7cUVBQWlCeUIsQ0FBQUEsT0FBUzs0QkFDeEIsR0FBR0EsSUFBSTs0QkFDUE8sVUFBVUwsS0FBS0MsR0FBRyxDQUFDLE1BQU1ELEtBQUtFLEdBQUcsQ0FBQyxJQUFJSixLQUFLTyxRQUFRLEdBQUdrRDt3QkFDeEQ7O1lBQ0Y7UUFDRjt3REFBRztRQUFDbEY7UUFBa0JDO0tBQVk7SUFFbEMsT0FBTztRQUNMVTtRQUNBb0M7UUFDQXVCO1FBQ0FTO0lBQ0Y7QUFDRixFQUFDIiwic291cmNlcyI6WyIvVXNlcnMvbXNuL3Byb2plY3RzL3R0ZXJtaW5hbC90dGVybWluYWwtZnJvbnRlbmQvaG9va3MvdHJhZGluZy91c2VDaGFydEludGVyYWN0aW9ucy50cyJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIENoYXJ0IEludGVyYWN0aW9ucyBIb29rXG4gKiBNYW5hZ2VzIG1vdXNlIGV2ZW50cywgZHJhd2luZyB0b29scywgYW5kIGNoYXJ0IGludGVyYWN0aW9ucyB3aXRoIHVsdHJhLWZhc3QgYXhpcy1zcGVjaWZpYyB6b29tXG4gKi9cblxuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCB9IGZyb20gJ3JlYWN0J1xuaW1wb3J0IHsgc2NyZWVuVG9DaGFydENvb3JkaW5hdGVzLCBpc1BvaW50SW5EcmF3aW5nIH0gZnJvbSAnLi4vLi4vdXRpbHMvdHJhZGluZy9jYWxjdWxhdGlvbnMnXG5pbXBvcnQgdHlwZSB7IENhbmRsZURhdGEsIERyYXdpbmcsIFZpZXdwb3J0U3RhdGUsIERyYWdTdGF0ZSB9IGZyb20gJy4uLy4uL3R5cGVzL3RyYWRpbmcnXG5cbmludGVyZmFjZSBVc2VDaGFydEludGVyYWN0aW9uc1Byb3BzIHtcbiAgY2FudmFzUmVmOiBSZWFjdC5SZWZPYmplY3Q8SFRNTENhbnZhc0VsZW1lbnQgfCBudWxsPlxuICBjYW5kbGVEYXRhOiBDYW5kbGVEYXRhW11cbiAgZHJhd2luZ01vZGU6IHN0cmluZyB8IG51bGxcbiAgZHJhd2luZ1Rvb2xzOiBEcmF3aW5nW11cbiAgc2VsZWN0ZWREcmF3aW5nSW5kZXg6IG51bWJlciB8IG51bGxcbiAgdmlld3BvcnRTdGF0ZTogVmlld3BvcnRTdGF0ZVxuICBkcmFnU3RhdGU6IERyYWdTdGF0ZVxuICBzZXRIb3ZlcmVkQ2FuZGxlOiAoY2FuZGxlOiBDYW5kbGVEYXRhIHwgbnVsbCkgPT4gdm9pZFxuICBzZXRNb3VzZVBvc2l0aW9uOiAocG9zOiBhbnkpID0+IHZvaWRcbiAgc2V0RHJhd2luZ1Rvb2xzOiAodG9vbHM6IERyYXdpbmdbXSB8ICgocHJldjogRHJhd2luZ1tdKSA9PiBEcmF3aW5nW10pKSA9PiB2b2lkXG4gIHNldFNlbGVjdGVkRHJhd2luZ0luZGV4OiAoaW5kZXg6IG51bWJlciB8IG51bGwpID0+IHZvaWRcbiAgc2V0RHJhd2luZ01vZGU6IChtb2RlOiBzdHJpbmcgfCBudWxsKSA9PiB2b2lkXG4gIHNldFNlbGVjdGVkRHJhd2luZ1Rvb2w6ICh0b29sOiBzdHJpbmcgfCBudWxsKSA9PiB2b2lkXG4gIHNldERyYWdTdGF0ZTogKHN0YXRlOiBEcmFnU3RhdGUgfCAoKHByZXY6IERyYWdTdGF0ZSkgPT4gRHJhZ1N0YXRlKSkgPT4gdm9pZFxuICBzZXRWaWV3cG9ydFN0YXRlOiAoc3RhdGU6IFZpZXdwb3J0U3RhdGUgfCAoKHByZXY6IFZpZXdwb3J0U3RhdGUpID0+IFZpZXdwb3J0U3RhdGUpKSA9PiB2b2lkXG59XG5cbmV4cG9ydCBjb25zdCB1c2VDaGFydEludGVyYWN0aW9ucyA9ICh7XG4gIGNhbnZhc1JlZixcbiAgY2FuZGxlRGF0YSxcbiAgZHJhd2luZ01vZGUsXG4gIGRyYXdpbmdUb29scyxcbiAgc2VsZWN0ZWREcmF3aW5nSW5kZXgsXG4gIHZpZXdwb3J0U3RhdGUsXG4gIGRyYWdTdGF0ZSxcbiAgc2V0SG92ZXJlZENhbmRsZSxcbiAgc2V0TW91c2VQb3NpdGlvbixcbiAgc2V0RHJhd2luZ1Rvb2xzLFxuICBzZXRTZWxlY3RlZERyYXdpbmdJbmRleCxcbiAgc2V0RHJhd2luZ01vZGUsXG4gIHNldFNlbGVjdGVkRHJhd2luZ1Rvb2wsXG4gIHNldERyYWdTdGF0ZSxcbiAgc2V0Vmlld3BvcnRTdGF0ZSxcbn06IFVzZUNoYXJ0SW50ZXJhY3Rpb25zUHJvcHMpID0+IHtcblxuICAvKipcbiAgICogRGV0ZWN0IGlmIG1vdXNlIGlzIG92ZXIgWS1heGlzIChwcmljZSBheGlzKSBvciBYLWF4aXMgKHRpbWUgYXhpcylcbiAgICovXG4gIGNvbnN0IGdldEF4aXNab25lID0gdXNlQ2FsbGJhY2soKHg6IG51bWJlciwgeTogbnVtYmVyLCBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50KSA9PiB7XG4gICAgY29uc3QgcHJpY2VBeGlzV2lkdGggPSA4MCAvLyBSaWdodCBzaWRlIHByaWNlIGF4aXMgKHctMjAgPSA4MHB4KVxuICAgIGNvbnN0IHRpbWVBeGlzSGVpZ2h0ID0gMzIgLy8gQm90dG9tIHRpbWUgYXhpcyAoaC04ID0gMzJweClcbiAgICBjb25zdCBjaGFydFdpZHRoID0gY2FudmFzLm9mZnNldFdpZHRoIC0gcHJpY2VBeGlzV2lkdGhcbiAgICBjb25zdCBjaGFydEhlaWdodCA9IGNhbnZhcy5vZmZzZXRIZWlnaHQgLSB0aW1lQXhpc0hlaWdodFxuICAgIFxuICAgIC8vIENoZWNrIGlmIGluIHByaWNlIGF4aXMgem9uZSAocmlnaHQgZWRnZSlcbiAgICBpZiAoeCA+IGNoYXJ0V2lkdGggJiYgeCA8PSBjYW52YXMub2Zmc2V0V2lkdGgpIHtcbiAgICAgIHJldHVybiAncHJpY2UtYXhpcydcbiAgICB9XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgaW4gdGltZSBheGlzIHpvbmUgKGJvdHRvbSBlZGdlKSAgXG4gICAgaWYgKHkgPiBjaGFydEhlaWdodCAmJiB5IDw9IGNhbnZhcy5vZmZzZXRIZWlnaHQpIHtcbiAgICAgIHJldHVybiAndGltZS1heGlzJ1xuICAgIH1cbiAgICBcbiAgICAvLyBDaGVjayBpZiBuZWFyIHByaWNlIGF4aXMgZWRnZSAoZm9yIGRyYWcgZGV0ZWN0aW9uKVxuICAgIGlmICh4ID4gY2hhcnRXaWR0aCAtIDEwICYmIHggPD0gY2hhcnRXaWR0aCArIDEwKSB7XG4gICAgICByZXR1cm4gJ3ByaWNlLWF4aXMtZWRnZSdcbiAgICB9XG4gICAgXG4gICAgLy8gQ2hlY2sgaWYgbmVhciB0aW1lIGF4aXMgZWRnZSAoZm9yIGRyYWcgZGV0ZWN0aW9uKVxuICAgIGlmICh5ID4gY2hhcnRIZWlnaHQgLSAxMCAmJiB5IDw9IGNoYXJ0SGVpZ2h0ICsgMTApIHtcbiAgICAgIHJldHVybiAndGltZS1heGlzLWVkZ2UnXG4gICAgfVxuICAgIFxuICAgIHJldHVybiAnY2hhcnQnXG4gIH0sIFtdKVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgbW91c2UgbW92ZW1lbnQgZm9yIGNyb3NzaGFpciwgY2FuZGxlIGhvdmVyLCBhbmQgYXhpcyBkZXRlY3Rpb25cbiAgICovXG4gIGNvbnN0IGhhbmRsZU1vdXNlTW92ZSA9IHVzZUNhbGxiYWNrKFxuICAgIChldmVudDogUmVhY3QuTW91c2VFdmVudDxIVE1MQ2FudmFzRWxlbWVudD4pID0+IHtcbiAgICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50XG4gICAgICBpZiAoIWNhbnZhcykgcmV0dXJuXG5cbiAgICAgIGNvbnN0IHJlY3QgPSBjYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KClcbiAgICAgIGNvbnN0IHggPSBldmVudC5jbGllbnRYIC0gcmVjdC5sZWZ0XG4gICAgICBjb25zdCB5ID0gZXZlbnQuY2xpZW50WSAtIHJlY3QudG9wXG5cbiAgICAgIC8vIEhhbmRsZSBhY3RpdmUgYXhpcyBkcmFnZ2luZyBvbmx5XG4gICAgICBpZiAoZHJhZ1N0YXRlLmlzRHJhZ2dpbmdQcmljZSkge1xuICAgICAgICBjb25zdCBkZWx0YVkgPSB5IC0gZHJhZ1N0YXRlLmRyYWdTdGFydC55XG4gICAgICAgIGNvbnN0IHNlbnNpdGl2aXR5ID0gMC4wMDIgLy8gVWx0cmEtc2Vuc2l0aXZlIGZvciBwcm9mZXNzaW9uYWwgdHJhZGluZ1xuICAgICAgICBjb25zdCB6b29tRmFjdG9yID0gMSArIChkZWx0YVkgKiBzZW5zaXRpdml0eSlcbiAgICAgICAgXG4gICAgICAgIHNldFZpZXdwb3J0U3RhdGUocHJldiA9PiAoe1xuICAgICAgICAgIC4uLnByZXYsXG4gICAgICAgICAgcHJpY2Vab29tOiBNYXRoLm1heCgwLjA1LCBNYXRoLm1pbig1MCwgcHJldi5wcmljZVpvb20gKiB6b29tRmFjdG9yKSlcbiAgICAgICAgfSkpXG4gICAgICAgIFxuICAgICAgICAvLyBVcGRhdGUgZHJhZyBzdGFydCBmb3IgY29udGludW91cyBtb3ZlbWVudFxuICAgICAgICBzZXREcmFnU3RhdGUocHJldiA9PiAoeyAuLi5wcmV2LCBkcmFnU3RhcnQ6IHsgeCwgeSB9IH0pKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgaWYgKGRyYWdTdGF0ZS5pc0RyYWdnaW5nVGltZSkge1xuICAgICAgICBjb25zdCBkZWx0YVggPSB4IC0gZHJhZ1N0YXRlLmRyYWdTdGFydC54XG4gICAgICAgIGNvbnN0IHNlbnNpdGl2aXR5ID0gMC4wMDIgLy8gVWx0cmEtc2Vuc2l0aXZlIGZvciBwcm9mZXNzaW9uYWwgdHJhZGluZ1xuICAgICAgICBjb25zdCB6b29tRmFjdG9yID0gMSArIChkZWx0YVggKiBzZW5zaXRpdml0eSlcbiAgICAgICAgXG4gICAgICAgIHNldFZpZXdwb3J0U3RhdGUocHJldiA9PiAoe1xuICAgICAgICAgIC4uLnByZXYsXG4gICAgICAgICAgdGltZVpvb206IE1hdGgubWF4KDAuMDUsIE1hdGgubWluKDUwLCBwcmV2LnRpbWVab29tICogem9vbUZhY3RvcikpXG4gICAgICAgIH0pKVxuICAgICAgICBcbiAgICAgICAgLy8gVXBkYXRlIGRyYWcgc3RhcnQgZm9yIGNvbnRpbnVvdXMgbW92ZW1lbnRcbiAgICAgICAgc2V0RHJhZ1N0YXRlKHByZXYgPT4gKHsgLi4ucHJldiwgZHJhZ1N0YXJ0OiB7IHgsIHkgfSB9KSlcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG5cbiAgICAgIC8vIERvbid0IGludGVyZmVyZSB3aXRoIGV4aXN0aW5nIGNoYXJ0IGRyYWdnaW5nIC0gbGV0IHRyYWRpbmcgdGVybWluYWwgaGFuZGxlIGl0XG4gICAgICBpZiAoZHJhZ1N0YXRlLmlzRHJhZ2dpbmdDaGFydCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gRGV0ZWN0IGF4aXMgem9uZXMgYW5kIHVwZGF0ZSBjdXJzb3JcbiAgICAgIGNvbnN0IGF4aXNab25lID0gZ2V0QXhpc1pvbmUoeCwgeSwgY2FudmFzKVxuICAgICAgaWYgKGF4aXNab25lID09PSAncHJpY2UtYXhpcycgfHwgYXhpc1pvbmUgPT09ICdwcmljZS1heGlzLWVkZ2UnKSB7XG4gICAgICAgIGNhbnZhcy5zdHlsZS5jdXJzb3IgPSAnbnMtcmVzaXplJ1xuICAgICAgfSBlbHNlIGlmIChheGlzWm9uZSA9PT0gJ3RpbWUtYXhpcycgfHwgYXhpc1pvbmUgPT09ICd0aW1lLWF4aXMtZWRnZScpIHtcbiAgICAgICAgY2FudmFzLnN0eWxlLmN1cnNvciA9ICdldy1yZXNpemUnXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjYW52YXMuc3R5bGUuY3Vyc29yID0gJ21vdmUnXG4gICAgICB9XG5cbiAgICAgIC8vIENhbGN1bGF0ZSB3aGljaCBjYW5kbGUgaXMgYmVpbmcgaG92ZXJlZFxuICAgICAgY29uc3QgY2FuZGxlV2lkdGggPSA4ICogdmlld3BvcnRTdGF0ZS50aW1lWm9vbVxuICAgICAgY29uc3Qgc3BhY2luZyA9IDEyICogdmlld3BvcnRTdGF0ZS50aW1lWm9vbVxuICAgICAgY29uc3Qgc3RhcnRYID0gNTBcbiAgICAgIGNvbnN0IGNhbmRsZUluZGV4ID0gTWF0aC5mbG9vcigoeCAtIHN0YXJ0WCArIHZpZXdwb3J0U3RhdGUudGltZU9mZnNldCkgLyBzcGFjaW5nKVxuXG4gICAgICBpZiAoY2FuZGxlSW5kZXggPj0gMCAmJiBjYW5kbGVJbmRleCA8IGNhbmRsZURhdGEubGVuZ3RoKSB7XG4gICAgICAgIHNldEhvdmVyZWRDYW5kbGUoY2FuZGxlRGF0YVtjYW5kbGVJbmRleF0pXG4gICAgICB9XG5cbiAgICAgIC8vIENhbGN1bGF0ZSBwcmljZSBhdCBtb3VzZSBwb3NpdGlvblxuICAgICAgY29uc3QgY2hhcnRIZWlnaHQgPSBjYW52YXMub2Zmc2V0SGVpZ2h0IC0gMTAwXG4gICAgICBjb25zdCBwcmljZVJhbmdlID0gKDExMzAwMCAtIDEwNzAwMCkgLyB2aWV3cG9ydFN0YXRlLnByaWNlWm9vbVxuICAgICAgY29uc3QgcHJpY2UgPSAxMTMwMDAgLSAoKHkgLSA1MCArIHZpZXdwb3J0U3RhdGUucHJpY2VPZmZzZXQpIC8gY2hhcnRIZWlnaHQpICogcHJpY2VSYW5nZVxuXG4gICAgICBzZXRNb3VzZVBvc2l0aW9uKHsgeCwgeSwgcHJpY2UgfSlcbiAgICB9LFxuICAgIFt2aWV3cG9ydFN0YXRlLCBjYW5kbGVEYXRhLCBkcmFnU3RhdGUsIHNldEhvdmVyZWRDYW5kbGUsIHNldE1vdXNlUG9zaXRpb24sIHNldFZpZXdwb3J0U3RhdGUsIHNldERyYWdTdGF0ZSwgZ2V0QXhpc1pvbmVdXG4gIClcblxuICAvKipcbiAgICogSGFuZGxlIG1vdXNlIGRvd24gZXZlbnRzIGZvciBheGlzIGRyYWdnaW5nIG9ubHlcbiAgICovXG4gIGNvbnN0IGhhbmRsZUNhbnZhc01vdXNlRG93biA9IHVzZUNhbGxiYWNrKChlOiBSZWFjdC5Nb3VzZUV2ZW50PEhUTUxDYW52YXNFbGVtZW50PikgPT4ge1xuICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1JlZi5jdXJyZW50XG4gICAgaWYgKCFjYW52YXMpIHJldHVyblxuXG4gICAgY29uc3QgcmVjdCA9IGNhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgIGNvbnN0IHggPSBlLmNsaWVudFggLSByZWN0LmxlZnRcbiAgICBjb25zdCB5ID0gZS5jbGllbnRZIC0gcmVjdC50b3BcblxuICAgIC8vIENoZWNrIGZvciBheGlzIGRyYWdnaW5nIGZpcnN0IC0gdGhpcyB0YWtlcyBwcmlvcml0eVxuICAgIGNvbnN0IGF4aXNab25lID0gZ2V0QXhpc1pvbmUoeCwgeSwgY2FudmFzKVxuICAgIFxuICAgIGlmIChheGlzWm9uZSA9PT0gJ3ByaWNlLWF4aXMnIHx8IGF4aXNab25lID09PSAncHJpY2UtYXhpcy1lZGdlJykge1xuICAgICAgc2V0RHJhZ1N0YXRlKHByZXYgPT4gKHtcbiAgICAgICAgLi4ucHJldixcbiAgICAgICAgaXNEcmFnZ2luZ1ByaWNlOiB0cnVlLFxuICAgICAgICBkcmFnU3RhcnQ6IHsgeCwgeSB9XG4gICAgICB9KSlcbiAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIFxuICAgIGlmIChheGlzWm9uZSA9PT0gJ3RpbWUtYXhpcycgfHwgYXhpc1pvbmUgPT09ICd0aW1lLWF4aXMtZWRnZScpIHtcbiAgICAgIHNldERyYWdTdGF0ZShwcmV2ID0+ICh7XG4gICAgICAgIC4uLnByZXYsXG4gICAgICAgIGlzRHJhZ2dpbmdUaW1lOiB0cnVlLFxuICAgICAgICBkcmFnU3RhcnQ6IHsgeCwgeSB9XG4gICAgICB9KSlcbiAgICAgIGUucHJldmVudERlZmF1bHQoKVxuICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gRm9yIGNoYXJ0IGFyZWEsIGxldCB0aGUgZXhpc3RpbmcgZHJhd2luZyBhbmQgY2hhcnQgZHJhZyBzeXN0ZW0gaGFuZGxlIGl0XG4gICAgY29uc3QgeyB0aW1lSW5kZXgsIHByaWNlIH0gPSBzY3JlZW5Ub0NoYXJ0Q29vcmRpbmF0ZXMoXG4gICAgICB4LCB5LCBjYW52YXMsIFxuICAgICAgdmlld3BvcnRTdGF0ZS50aW1lWm9vbSwgXG4gICAgICB2aWV3cG9ydFN0YXRlLnByaWNlWm9vbSxcbiAgICAgIHZpZXdwb3J0U3RhdGUudGltZU9mZnNldCwgXG4gICAgICB2aWV3cG9ydFN0YXRlLnByaWNlT2Zmc2V0XG4gICAgKVxuXG4gICAgLy8gRmluZCBjbGlja2VkIGRyYXdpbmdcbiAgICBsZXQgY2xpY2tlZERyYXdpbmdJbmRleCA9IC0xXG4gICAgbGV0IGNsb3Nlc3REaXN0YW5jZSA9IEluZmluaXR5XG5cbiAgICBkcmF3aW5nVG9vbHMuZm9yRWFjaCgodG9vbCwgaW5kZXgpID0+IHtcbiAgICAgIGlmIChpc1BvaW50SW5EcmF3aW5nKHRpbWVJbmRleCwgcHJpY2UsIHRvb2wpKSB7XG4gICAgICAgIGlmICh0b29sLnR5cGUgPT09IFwiSG9yaXpvbnRhbCBSYXlcIikge1xuICAgICAgICAgIGNvbnN0IGRpc3RhbmNlID0gTWF0aC5hYnMocHJpY2UgLSB0b29sLnByaWNlMSlcbiAgICAgICAgICBpZiAoZGlzdGFuY2UgPCBjbG9zZXN0RGlzdGFuY2UpIHtcbiAgICAgICAgICAgIGNsb3Nlc3REaXN0YW5jZSA9IGRpc3RhbmNlXG4gICAgICAgICAgICBjbGlja2VkRHJhd2luZ0luZGV4ID0gaW5kZXhcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY2xpY2tlZERyYXdpbmdJbmRleCA9IGluZGV4XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KVxuXG4gICAgLy8gUmlnaHQtY2xpY2sgdG8gcmVtb3ZlIGRyYXdpbmdzXG4gICAgaWYgKGUuYnV0dG9uID09PSAyKSB7XG4gICAgICBlLnByZXZlbnREZWZhdWx0KClcbiAgICAgIGlmIChjbGlja2VkRHJhd2luZ0luZGV4ICE9PSAtMSkge1xuICAgICAgICBzZXREcmF3aW5nVG9vbHMoKHByZXYpID0+IHtcbiAgICAgICAgICBjb25zdCB1cGRhdGVkVG9vbHMgPSBbLi4ucHJldl1cbiAgICAgICAgICB1cGRhdGVkVG9vbHMuc3BsaWNlKGNsaWNrZWREcmF3aW5nSW5kZXgsIDEpXG4gICAgICAgICAgcmV0dXJuIHVwZGF0ZWRUb29sc1xuICAgICAgICB9KVxuICAgICAgICBzZXRTZWxlY3RlZERyYXdpbmdJbmRleChudWxsKVxuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gTGVmdC1jbGljayB0byBzZWxlY3QgZHJhd2luZyBvciBzdGFydCBuZXcgZHJhd2luZ1xuICAgIGlmIChjbGlja2VkRHJhd2luZ0luZGV4ICE9PSAtMSkge1xuICAgICAgc2V0U2VsZWN0ZWREcmF3aW5nSW5kZXgoY2xpY2tlZERyYXdpbmdJbmRleClcbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSB7XG4gICAgICBzZXRTZWxlY3RlZERyYXdpbmdJbmRleChudWxsKVxuICAgIH1cblxuICAgIC8vIEhhbmRsZSBkcmF3aW5nIG1vZGVcbiAgICBpZiAoZHJhd2luZ01vZGUgPT09IFwiSG9yaXpvbnRhbCBSYXlcIikge1xuICAgICAgc2V0RHJhd2luZ1Rvb2xzKChwcmV2KSA9PiBbXG4gICAgICAgIC4uLnByZXYsXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcIkhvcml6b250YWwgUmF5XCIsXG4gICAgICAgICAgcHJpY2UxOiBwcmljZSxcbiAgICAgICAgICB0aW1lMTogMCxcbiAgICAgICAgICBwcmljZTI6IHByaWNlLFxuICAgICAgICAgIHRpbWUyOiBjYW5kbGVEYXRhLmxlbmd0aCxcbiAgICAgICAgICBjb2xvcjogXCIjZmZmZjAwXCIsXG4gICAgICAgICAgbGluZVdpZHRoOiAxLFxuICAgICAgICB9LFxuICAgICAgXSlcbiAgICAgIHNldERyYXdpbmdNb2RlKG51bGwpXG4gICAgICBzZXRTZWxlY3RlZERyYXdpbmdUb29sKG51bGwpXG4gICAgfSBlbHNlIGlmIChkcmF3aW5nTW9kZSA9PT0gXCJSZWN0YW5nbGVcIikge1xuICAgICAgc2V0RHJhd2luZ1Rvb2xzKChwcmV2KSA9PiBbXG4gICAgICAgIC4uLnByZXYsXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiBcIlJlY3RhbmdsZVwiLFxuICAgICAgICAgIHByaWNlMTogcHJpY2UsXG4gICAgICAgICAgdGltZTE6IHRpbWVJbmRleCxcbiAgICAgICAgICBwcmljZTI6IHByaWNlLFxuICAgICAgICAgIHRpbWUyOiB0aW1lSW5kZXgsXG4gICAgICAgICAgY29sb3I6IFwiI2ZmZmYwMFwiLFxuICAgICAgICAgIGxpbmVXaWR0aDogMSxcbiAgICAgICAgfSxcbiAgICAgIF0pXG4gICAgfVxuXG4gICAgLy8gTGV0IHRoZSB0cmFkaW5nIHRlcm1pbmFsIGhhbmRsZSBjaGFydCBwYW5uaW5nIC0gZG9uJ3Qgc2V0IGlzRHJhZ2dpbmdDaGFydCBoZXJlXG4gIH0sIFtjYW52YXNSZWYsIHZpZXdwb3J0U3RhdGUsIGRyYXdpbmdUb29scywgZHJhd2luZ01vZGUsIGNhbmRsZURhdGEsIHNldERyYXdpbmdUb29scywgc2V0U2VsZWN0ZWREcmF3aW5nSW5kZXgsIHNldERyYXdpbmdNb2RlLCBzZXRTZWxlY3RlZERyYXdpbmdUb29sLCBzZXREcmFnU3RhdGUsIGdldEF4aXNab25lXSlcblxuICAvKipcbiAgICogSGFuZGxlIG1vdXNlIHVwIGV2ZW50cyB0byBzdG9wIGF4aXMgZHJhZ2dpbmdcbiAgICovXG4gIGNvbnN0IGhhbmRsZUF4aXNEcmFnRW5kID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIHNldERyYWdTdGF0ZShwcmV2ID0+ICh7XG4gICAgICAuLi5wcmV2LFxuICAgICAgaXNEcmFnZ2luZ1ByaWNlOiBmYWxzZSxcbiAgICAgIGlzRHJhZ2dpbmdUaW1lOiBmYWxzZSxcbiAgICAgIGlzRHJhZ2dpbmdDaGFydDogZmFsc2UsXG4gICAgICBpc0RyYWdnaW5nT3JkZXJib29rOiBmYWxzZSxcbiAgICAgIGlzRHJhZ2dpbmdDdmQ6IGZhbHNlLFxuICAgICAgaXNEcmFnZ2luZ0xpcXVpZGF0aW9uczogZmFsc2VcbiAgICB9KSlcbiAgfSwgW3NldERyYWdTdGF0ZV0pXG5cbiAgLyoqXG4gICAqIEhhbmRsZSBrZXlib2FyZCBzaG9ydGN1dHMgZm9yIGRyYXdpbmcgbWFuYWdlbWVudFxuICAgKi9cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBoYW5kbGVLZXlEb3duID0gKGV2ZW50OiBLZXlib2FyZEV2ZW50KSA9PiB7XG4gICAgICBpZiAoZXZlbnQua2V5ID09PSAnRGVsZXRlJyB8fCBldmVudC5rZXkgPT09ICdCYWNrc3BhY2UnKSB7XG4gICAgICAgIGlmIChzZWxlY3RlZERyYXdpbmdJbmRleCAhPT0gbnVsbCkge1xuICAgICAgICAgIHNldERyYXdpbmdUb29scygocHJldikgPT4ge1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlZFRvb2xzID0gWy4uLnByZXZdXG4gICAgICAgICAgICB1cGRhdGVkVG9vbHMuc3BsaWNlKHNlbGVjdGVkRHJhd2luZ0luZGV4LCAxKVxuICAgICAgICAgICAgcmV0dXJuIHVwZGF0ZWRUb29sc1xuICAgICAgICAgIH0pXG4gICAgICAgICAgc2V0U2VsZWN0ZWREcmF3aW5nSW5kZXgobnVsbClcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgXG4gICAgICBpZiAoZXZlbnQua2V5ID09PSAnRXNjYXBlJykge1xuICAgICAgICBzZXRTZWxlY3RlZERyYXdpbmdJbmRleChudWxsKVxuICAgICAgICBzZXREcmF3aW5nTW9kZShudWxsKVxuICAgICAgICBzZXRTZWxlY3RlZERyYXdpbmdUb29sKG51bGwpXG4gICAgICAgIC8vIFN0b3AgYW55IGRyYWdnaW5nXG4gICAgICAgIHNldERyYWdTdGF0ZShwcmV2ID0+ICh7XG4gICAgICAgICAgLi4ucHJldixcbiAgICAgICAgICBpc0RyYWdnaW5nUHJpY2U6IGZhbHNlLFxuICAgICAgICAgIGlzRHJhZ2dpbmdUaW1lOiBmYWxzZSxcbiAgICAgICAgICBpc0RyYWdnaW5nQ2hhcnQ6IGZhbHNlLFxuICAgICAgICAgIGlzRHJhZ2dpbmdPcmRlcmJvb2s6IGZhbHNlLFxuICAgICAgICAgIGlzRHJhZ2dpbmdDdmQ6IGZhbHNlLFxuICAgICAgICAgIGlzRHJhZ2dpbmdMaXF1aWRhdGlvbnM6IGZhbHNlXG4gICAgICAgIH0pKVxuICAgICAgfVxuICAgIH1cblxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVLZXlEb3duKVxuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgaGFuZGxlS2V5RG93bilcbiAgICB9XG4gIH0sIFtzZWxlY3RlZERyYXdpbmdJbmRleCwgc2V0RHJhd2luZ1Rvb2xzLCBzZXRTZWxlY3RlZERyYXdpbmdJbmRleCwgc2V0RHJhd2luZ01vZGUsIHNldFNlbGVjdGVkRHJhd2luZ1Rvb2wsIHNldERyYWdTdGF0ZV0pXG5cbiAgLyoqXG4gICAqIEhhbmRsZSB3aGVlbCBldmVudHMgZm9yIHVsdHJhLWZhc3Qgem9vbWluZyB3aXRoIGF4aXMgZGV0ZWN0aW9uXG4gICAqL1xuICBjb25zdCBoYW5kbGVXaGVlbCA9IHVzZUNhbGxiYWNrKChlOiBXaGVlbEV2ZW50KSA9PiB7XG4gICAgZS5wcmV2ZW50RGVmYXVsdCgpXG4gICAgXG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnRcbiAgICBpZiAoIWNhbnZhcykgcmV0dXJuXG5cbiAgICBjb25zdCByZWN0ID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgY29uc3QgeCA9IGUuY2xpZW50WCAtIHJlY3QubGVmdFxuICAgIGNvbnN0IHkgPSBlLmNsaWVudFkgLSByZWN0LnRvcFxuICAgIFxuICAgIC8vIERldGVjdCB3aGljaCBheGlzIHdlJ3JlIGhvdmVyaW5nIG92ZXJcbiAgICBjb25zdCBheGlzWm9uZSA9IGdldEF4aXNab25lKHgsIHksIGNhbnZhcylcbiAgICBcbiAgICAvLyBVbHRyYS1hZ2dyZXNzaXZlIHpvb20gZmFjdG9ycyBmb3IgbGlnaHRuaW5nLWZhc3QgcmVzcG9uc2VcbiAgICBjb25zdCB3aGVlbFNlbnNpdGl2aXR5ID0gTWF0aC5hYnMoZS5kZWx0YVkpIC8gNTAgLy8gSW5jcmVhc2VkIHNlbnNpdGl2aXR5XG4gICAgY29uc3QgYmFzZVpvb21GYWN0b3IgPSBlLmRlbHRhWSA+IDAgPyAwLjggOiAxLjI1IC8vIE1vcmUgYWdncmVzc2l2ZSBiYXNlIHpvb21cbiAgICBjb25zdCBkeW5hbWljWm9vbUZhY3RvciA9IGUuZGVsdGFZID4gMCBcbiAgICAgID8gTWF0aC5tYXgoMC4zLCAxIC0gd2hlZWxTZW5zaXRpdml0eSAqIDAuNCkgIC8vIFVsdHJhLWZhc3Qgem9vbSBvdXRcbiAgICAgIDogTWF0aC5taW4oMy4wLCAxICsgd2hlZWxTZW5zaXRpdml0eSAqIDAuNSkgIC8vIFVsdHJhLWZhc3Qgem9vbSBpblxuXG4gICAgLy8gQXhpcy1zcGVjaWZpYyB6b29taW5nXG4gICAgaWYgKGF4aXNab25lID09PSAncHJpY2UtYXhpcycgfHwgYXhpc1pvbmUgPT09ICdwcmljZS1heGlzLWVkZ2UnIHx8IGUuY3RybEtleSB8fCBlLm1ldGFLZXkpIHtcbiAgICAgIC8vIFByaWNlIHpvb20gKHZlcnRpY2FsKSAtIHVsdHJhIHJlc3BvbnNpdmVcbiAgICAgIHNldFZpZXdwb3J0U3RhdGUocHJldiA9PiAoe1xuICAgICAgICAuLi5wcmV2LFxuICAgICAgICBwcmljZVpvb206IE1hdGgubWF4KDAuMDUsIE1hdGgubWluKDUwLCBwcmV2LnByaWNlWm9vbSAqIGR5bmFtaWNab29tRmFjdG9yKSlcbiAgICAgIH0pKVxuICAgIH0gZWxzZSBpZiAoYXhpc1pvbmUgPT09ICd0aW1lLWF4aXMnIHx8IGF4aXNab25lID09PSAndGltZS1heGlzLWVkZ2UnKSB7XG4gICAgICAvLyBUaW1lIHpvb20gKGhvcml6b250YWwpIC0gdWx0cmEgcmVzcG9uc2l2ZSAgXG4gICAgICBzZXRWaWV3cG9ydFN0YXRlKHByZXYgPT4gKHtcbiAgICAgICAgLi4ucHJldixcbiAgICAgICAgdGltZVpvb206IE1hdGgubWF4KDAuMDUsIE1hdGgubWluKDUwLCBwcmV2LnRpbWVab29tICogZHluYW1pY1pvb21GYWN0b3IpKVxuICAgICAgfSkpXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIERlZmF1bHQgYmVoYXZpb3IgLSB0aW1lIHpvb20gd2hlbiBubyBtb2RpZmllclxuICAgICAgc2V0Vmlld3BvcnRTdGF0ZShwcmV2ID0+ICh7XG4gICAgICAgIC4uLnByZXYsXG4gICAgICAgIHRpbWVab29tOiBNYXRoLm1heCgwLjA1LCBNYXRoLm1pbig1MCwgcHJldi50aW1lWm9vbSAqIGR5bmFtaWNab29tRmFjdG9yKSlcbiAgICAgIH0pKVxuICAgIH1cbiAgfSwgW3NldFZpZXdwb3J0U3RhdGUsIGdldEF4aXNab25lXSlcblxuICByZXR1cm4ge1xuICAgIGhhbmRsZU1vdXNlTW92ZSxcbiAgICBoYW5kbGVDYW52YXNNb3VzZURvd24sXG4gICAgaGFuZGxlQXhpc0RyYWdFbmQsXG4gICAgaGFuZGxlV2hlZWwsXG4gIH1cbn0gIl0sIm5hbWVzIjpbInVzZUNhbGxiYWNrIiwidXNlRWZmZWN0Iiwic2NyZWVuVG9DaGFydENvb3JkaW5hdGVzIiwiaXNQb2ludEluRHJhd2luZyIsInVzZUNoYXJ0SW50ZXJhY3Rpb25zIiwiY2FudmFzUmVmIiwiY2FuZGxlRGF0YSIsImRyYXdpbmdNb2RlIiwiZHJhd2luZ1Rvb2xzIiwic2VsZWN0ZWREcmF3aW5nSW5kZXgiLCJ2aWV3cG9ydFN0YXRlIiwiZHJhZ1N0YXRlIiwic2V0SG92ZXJlZENhbmRsZSIsInNldE1vdXNlUG9zaXRpb24iLCJzZXREcmF3aW5nVG9vbHMiLCJzZXRTZWxlY3RlZERyYXdpbmdJbmRleCIsInNldERyYXdpbmdNb2RlIiwic2V0U2VsZWN0ZWREcmF3aW5nVG9vbCIsInNldERyYWdTdGF0ZSIsInNldFZpZXdwb3J0U3RhdGUiLCJnZXRBeGlzWm9uZSIsIngiLCJ5IiwiY2FudmFzIiwicHJpY2VBeGlzV2lkdGgiLCJ0aW1lQXhpc0hlaWdodCIsImNoYXJ0V2lkdGgiLCJvZmZzZXRXaWR0aCIsImNoYXJ0SGVpZ2h0Iiwib2Zmc2V0SGVpZ2h0IiwiaGFuZGxlTW91c2VNb3ZlIiwiZXZlbnQiLCJjdXJyZW50IiwicmVjdCIsImdldEJvdW5kaW5nQ2xpZW50UmVjdCIsImNsaWVudFgiLCJsZWZ0IiwiY2xpZW50WSIsInRvcCIsImlzRHJhZ2dpbmdQcmljZSIsImRlbHRhWSIsImRyYWdTdGFydCIsInNlbnNpdGl2aXR5Iiwiem9vbUZhY3RvciIsInByZXYiLCJwcmljZVpvb20iLCJNYXRoIiwibWF4IiwibWluIiwiaXNEcmFnZ2luZ1RpbWUiLCJkZWx0YVgiLCJ0aW1lWm9vbSIsImlzRHJhZ2dpbmdDaGFydCIsImF4aXNab25lIiwic3R5bGUiLCJjdXJzb3IiLCJjYW5kbGVXaWR0aCIsInNwYWNpbmciLCJzdGFydFgiLCJjYW5kbGVJbmRleCIsImZsb29yIiwidGltZU9mZnNldCIsImxlbmd0aCIsInByaWNlUmFuZ2UiLCJwcmljZSIsInByaWNlT2Zmc2V0IiwiaGFuZGxlQ2FudmFzTW91c2VEb3duIiwiZSIsInByZXZlbnREZWZhdWx0Iiwic3RvcFByb3BhZ2F0aW9uIiwidGltZUluZGV4IiwiY2xpY2tlZERyYXdpbmdJbmRleCIsImNsb3Nlc3REaXN0YW5jZSIsIkluZmluaXR5IiwiZm9yRWFjaCIsInRvb2wiLCJpbmRleCIsInR5cGUiLCJkaXN0YW5jZSIsImFicyIsInByaWNlMSIsImJ1dHRvbiIsInVwZGF0ZWRUb29scyIsInNwbGljZSIsInRpbWUxIiwicHJpY2UyIiwidGltZTIiLCJjb2xvciIsImxpbmVXaWR0aCIsImhhbmRsZUF4aXNEcmFnRW5kIiwiaXNEcmFnZ2luZ09yZGVyYm9vayIsImlzRHJhZ2dpbmdDdmQiLCJpc0RyYWdnaW5nTGlxdWlkYXRpb25zIiwiaGFuZGxlS2V5RG93biIsImtleSIsImRvY3VtZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJoYW5kbGVXaGVlbCIsIndoZWVsU2Vuc2l0aXZpdHkiLCJiYXNlWm9vbUZhY3RvciIsImR5bmFtaWNab29tRmFjdG9yIiwiY3RybEtleSIsIm1ldGFLZXkiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/trading/useChartInteractions.ts\n"));

/***/ })

});